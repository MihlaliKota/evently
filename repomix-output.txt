This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
backend/.env
backend/package.json
backend/server.js
evently_db_backup.sql
frontend/.env
frontend/.env  .development
frontend/.env.production
frontend/.gitignore
frontend/.npmrc
frontend/eslint.config.js
frontend/generate-env.js
frontend/index.html
frontend/package.json
frontend/public/vite.svg
frontend/README.md
frontend/src/App.css
frontend/src/App.jsx
frontend/src/assets/react.svg
frontend/src/components/CreateEventForm.jsx
frontend/src/components/Dashboard.jsx
frontend/src/components/EventDetail.jsx
frontend/src/components/EventsList.jsx
frontend/src/components/LandingPage.jsx
frontend/src/components/LoginForm.jsx
frontend/src/components/RegisterForm.jsx
frontend/src/components/ReviewDialog.jsx
frontend/src/components/SimpleEventCalendar.jsx
frontend/src/components/StarRating.jsx
frontend/src/components/UserProfile.jsx
frontend/src/index.css
frontend/src/main.jsx
frontend/src/utils/api.js
frontend/src/utils/CalendarExport.js
frontend/src/utils/getApiUrl.js
frontend/vite.config.js
railway.json
vercel.json

================================================================
Files
================================================================

================
File: .gitignore
================
node_modules/
frontend/node_modules/
backend/node_modules/

================
File: backend/.env
================
DB_HOST=mysql.railway.internal
DB_PORT=3386
DB_USER=root
DB_PASSWORD=bneaZOaeIzYqOaz_jeeoqQP1hpcdRFTNC
DB_DATABASE=railway
JWT_SECRET=WI8momxIK8NST7Sf8eUukjKxEVIsbCYJzPeai6gibQa6ZEsjK3SCEGDSTbuQg/xG
Iu7JUAk3CymiU8p0lqdpvA==

================
File: backend/package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "jsonwebtoken": "^9.0.2",
    "mysql2": "^3.12.0"
  }
}

================
File: backend/server.js
================
require('dotenv').config(); // Load environment variables from .env file

const express = require('express');
const mysql = require('mysql2/promise'); // Import mysql2/promise for promise-based API
const cors = require('cors'); // For Cross-Origin Resource Sharing (CORS) - allows AJAX requests from the frontend
const bcrypt = require('bcrypt'); // For password hashing
const jwt = require('jsonwebtoken'); // For JWT token generation

const app = express();
app.use(express.json());

// Add middleware to parse JSON request bodies
const corsOptions = {
    origin: [
        'http://localhost:5173',             // Local development
        'https://evently-five-pi.vercel.app', // Vercel deployment
        'https://evently-production-cd21.up.railway.app', // Production backend
    ],
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: [
        'Content-Type',
        'Authorization',
        'Origin',
        'X-Requested-With',
        'Accept'
    ],
    credentials: true,
    optionsSuccessStatus: 200
};

app.use(cors(corsOptions));

const port = process.env.PORT ? parseInt(process.env.PORT) : 5000;

// Database connection pool configuration
const pool = mysql.createPool({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE,
    port: process.env.DB_PORT || 3306,
    connectionLimit: 10
});

// Test database connection
async function testDatabaseConnection() {
    let connection;
    try {
        console.log('Attempting database connection with:');
        console.log(`Host: ${process.env.DB_HOST}`);
        console.log(`User: ${process.env.DB_USER}`);
        console.log(`Database: ${process.env.DB_DATABASE}`);
        console.log(`Port: ${process.env.DB_PORT}`);

        connection = await pool.getConnection();
        const [rows, fields] = await connection.query('SELECT 1 + 1 AS solution');
        console.log('Database connection successful!');
        console.log('Test query result:', rows[0].solution);
    } catch (error) {
        console.error('Database connection failed:', error);
        console.error('Error details:', error.message, error.code);
    } finally {
        if (connection) {
            connection.release();
        }
    }
}

// ------------------- JWT Middleware for Protected Routes -------------------

const authenticateJWT = (req, res, next) => {
    const authHeader = req.headers.authorization;

    if (authHeader) {
        const token = authHeader.split(' ')[1]; // Extract token from "Bearer <token>"

        jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
            if (err) {
                console.error('JWT Verification Error:', err); // Log detailed error for debugging
                return res.sendStatus(403); // 403 Forbidden - Token invalid or expired
            }

            req.user = user; // Attach user info from token to the request object
            next(); // Proceed to the next middleware or route handler

        });
    } else {
        res.sendStatus(401); // 401 Unauthorized - No token provided
    }
};

// ------------------- Authentication API Endpoints -------------------

// POST /api/register - User Registration
app.post('/api/register', async (req, res) => {
    console.group('ðŸ” Registration Attempt');
    console.log('Request Origin:', req.get('origin'));
    console.log('Request Headers:', req.headers);
    console.log('Request Body:', req.body);

    try {
        const { username, password, email } = req.body;

        // Validate input
        if (!username || !email || !password) {
            return res.status(400).json({
                error: 'All fields are required',
                details: {
                    username: !!username,
                    email: !!email,
                    password: !!password
                }
            });
        }

        // Validate email
        if (!email || !email.includes('@')) {
            return res.status(400).json({
                error: 'A valid email address is required'
            });
        }

        const connection = await pool.getConnection();
        try {
            // Check if username already exists
            const [existingUsers] = await connection.query(
                'SELECT * FROM users WHERE username = ?',
                [username]
            );

            if (existingUsers.length > 0) {
                return res.status(409).json({ error: 'Username already taken.' });
            }

            // Determine role
            let role = 'user'; // Default roles

            // Hash the password
            const saltRounds = 10;
            const passwordHash = await bcrypt.hash(password, saltRounds);

            // Insert new user with email
            const [result] = await connection.query(
                'INSERT INTO users (username, password_hash, email, role) VALUES (?, ?, ?, ?)',
                [username, passwordHash, email, role]
            );

            // Send success response with role
            res.status(201).json({
                message: 'User registered successfully',
                userId: result.insertId,
                role: role
            });

        } finally {
            connection.release();
        }

    } catch (error) {
        console.error('Registration Error:', error);
        res.status(500).json({
            error: 'Registration failed',
            details: error.message,
            debugInfo: {
                origin: req.get('origin'),
                headers: req.headers
            }
        });
    }
});

// POST /api/login - User Login and JWT Generation
app.post('/api/login', async (req, res) => {
    console.log('Login attempt initiated for username:', req.body.username);
    console.log('Request headers:', req.headers);
    try {
        const { username, password } = req.body;

        // 1. Input validation
        if (!username || !password) {
            console.log('Login failed: Missing username or password');
            return res.status(400).json({ error: 'Username and password are required.' });
        }

        console.log('Attempting to retrieve user from database for username:', username);

        // 2. Retrieve user from database
        const connection = await pool.getConnection();
        try {
            const [users] = await connection.query(
                'SELECT * FROM users WHERE username = ?',
                [username]
            );

            console.log('Database query completed. Found users:', users.length);

            if (users.length === 0) {
                console.log('Login failed: User not found in database');
                return res.status(401).json({ error: 'Invalid credentials' }); // 401 Unauthorized - incorrect username
            }

            const user = users[0]; // Get the first user from the results
            console.log('User found in database, ID:', user.user_id, 'Role:', user.role);

            // 3. Compare password hashes
            console.log('Comparing provided password with stored hash...');
            const passwordMatch = await bcrypt.compare(password, user.password_hash);
            console.log('Password comparison result:', passwordMatch);

            if (!passwordMatch) {
                // This was the bug - the condition was inverted
                console.log('Login failed: Password does not match');
                return res.status(401).json({ error: 'Invalid credentials' }); // 401 Unauthorized - incorrect password
            }

            // 4. Generate JWT token with role included in payload
            console.log('Generating JWT token for user...');
            const payload = {
                userId: user.user_id,
                username: user.username
            };

            // Log JWT secret availability (not the actual secret)
            console.log('JWT_SECRET environment variable available:', !!process.env.JWT_SECRET);

            if (!process.env.JWT_SECRET) {
                console.error('ERROR: JWT_SECRET environment variable is not defined!');
                return res.status(500).json({ error: 'Server configuration error - missing JWT secret' });
            }

            const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1h' }); // Token expires in 1 hour
            console.log('JWT token generated successfully');

            // 5. Send successful login response with JWT token
            console.log('Login successful for user:', username);
            res.status(200).json({
                message: 'Login successful',
                token: token,
                username: user.username,
                role: user.role || 'user'
            }); // 200 OK

        } catch (dbError) {
            console.error('Database error during login process:', dbError);
            res.status(500).json({ error: 'Database error during authentication', details: dbError.message });
        } finally {
            connection.release();
            console.log('Database connection released');
        }

    } catch (error) {
        console.error('Unexpected login error:', error);
        console.error('Error stack trace:', error.stack);
        res.status(500).json({ error: 'Server configuration error', details: error.message }); // 500 Internal Server Error - generic error for login failures
    }
});

// ------------------- Protected API Endpoint -------------------

// GET /api/protected - Requires JWT authentication
app.get('/api/protected', authenticateJWT, (req, res) => {
    // If authenticateJWT middleware succeeds (calls next()), we reach here, meaning user is authenticated

    res.json({
        message: 'Protected endpoint accessed successfully!',
        user: req.user, // You can access user information from req.user (set by authenticateJWT)
        timestamp: new Date().toISOString()
    });
});


// ------------------- Existing Event and Category API Endpoints (No Changes Here) -------------------

app.post('/api/events', authenticateJWT, async (req, res) => {
    try {
        const userId = req.user.userId;
        const { 
            name, 
            description, 
            event_date, 
            location, 
            event_type = null, 
            category_id 
        } = req.body;

        // Validate required fields
        if (!name || !category_id || !event_date) {
            return res.status(400).json({ 
                error: 'Name, category_id, and event_date are required.',
                missingFields: {
                    name: !name,
                    category_id: !category_id,
                    event_date: !event_date
                }
            });
        }

        const connection = await pool.getConnection();
        
        try {
            // Validate category exists
            const [categoryCheck] = await connection.query(
                'SELECT * FROM eventcategories WHERE category_id = ?',
                [category_id]
            );

            if (categoryCheck.length === 0) {
                return res.status(404).json({ error: 'Selected category does not exist.' });
            }

            // Insert the event with all fields
            const [result] = await connection.query(
                `INSERT INTO events 
                (user_id, category_id, name, description, event_date, location, event_type, created_at, updated_at) 
                VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
                [
                    userId, 
                    category_id, 
                    name.trim(), 
                    description ? description.trim() : null, 
                    event_date, 
                    location ? location.trim() : null,
                    event_type
                ]
            );
            
            // Retrieve the newly created event
            const [newEvent] = await connection.query(
                'SELECT * FROM events WHERE event_id = ?',
                [result.insertId]
            );
            
            res.status(201).json(newEvent[0]);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Event Creation Error:', error);
        res.status(500).json({ 
            error: 'Failed to create event', 
            details: error.message
        });
    }
});

// GET /api/events - Get all events - WITH PAGINATION AND SORTING
app.get('/api/events', async (req, res) => {
    console.log(`GET /api/events - Start processing request, query parameters:`, req.query);

    // 1. Pagination parameters (from query parameters, with defaults)
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const offset = (page - 1) * limit;

    // 2. Sorting parameters (new!)
    const sortBy = req.query.sort_by;
    const sortOrder = req.query.sort_order;

    console.log(`GET /api/events - Pagination parameters: page=${page}, limit=${limit}, offset=${offset}`);
    console.log(`GET /api/events - Sorting parameters: sortBy=${sortBy}, sortOrder=${sortOrder}`); // Log sorting parameters

    // 3. Validate and sanitize sort_by and sort_order
    let orderByClause = '';
    const validSortFields = ['name', 'event_date', 'category_id']; // Valid fields to sort by
    const validSortOrders = ['asc', 'desc'];
    let sqlSortBy = null; // Variable to hold validated sort field for SQL query

    if (sortBy && validSortFields.includes(sortBy)) {
        sqlSortBy = sortBy; // Use the provided sortBy if it's valid
        let sqlSortOrder = 'ASC'; // Default sort order is ASC
        if (sortOrder && validSortOrders.includes(sortOrder.toLowerCase())) {
            sqlSortOrder = sortOrder.toUpperCase(); // Use provided sortOrder if valid, convert to uppercase for SQL
        }
        orderByClause = `ORDER BY ${sqlSortBy} ${sqlSortOrder}`; // Construct ORDER BY clause
        console.log(`GET /api/events - ORDER BY clause: ${orderByClause}`); // Log ORDER BY clause
    } else if (sortBy) {
        console.log(`GET /api/events - Invalid sort_by field: ${sortBy}. Sorting will be disabled.`); // Log invalid sort field
    }


    // 4. Database connection
    try {
        const connection = await pool.getConnection();
        console.log(`GET /api/events - Database connection acquired`);

        try {
            // --- 4.3.1: Get total count of events (for metadata) ---
            const countQuery = 'SELECT COUNT(*) AS total_count FROM events';
            console.log(`GET /api/events - SQL query for total count: ${countQuery}`);
            const [countResult] = await connection.query(countQuery);
            const totalCount = countResult[0].total_count;
            console.log(`GET /api/events - Total events count: ${totalCount}`);

            // --- 4.3.2 & 6.1: Modified SQL query with LIMIT, OFFSET, and ORDER BY (if applicable) ---
            let eventsQuery = 'SELECT * FROM events'; // Base query
            if (orderByClause) {
                eventsQuery += ` ${orderByClause}`; // Append ORDER BY if sorting is enabled
            }
            eventsQuery += ' LIMIT ? OFFSET ?'; // Append pagination LIMIT and OFFSET
            const sqlParams = [limit, offset];
            console.log(`GET /api/events - SQL query for events: ${eventsQuery} Parameters:`, sqlParams);
            const [rows] = await connection.query(eventsQuery, sqlParams);

            // --- 4.3.3: Calculate pagination metadata ---
            const totalPages = Math.ceil(totalCount / limit);
            const currentPage = page;
            const perPage = limit;

            // --- 4.3.4: Add pagination metadata to response headers ---
            res.setHeader('X-Total-Count', totalCount);
            res.setHeader('X-Total-Pages', totalPages);
            res.setHeader('X-Current-Page', currentPage);
            res.setHeader('X-Per-Page', perPage);

            // 5. Send response with events (and metadata in headers!)
            res.status(200).json(rows);
            console.log(`GET /api/events - Retrieved ${rows.length} events, 200 response sent (with pagination metadata and sorting)`);

        } finally {
            connection.release();
            console.log(`GET /api/events - Database connection released`);
        }

    } catch (error) {
        console.error('Error fetching events:', error);
        res.status(500).json({ error: 'Failed to fetch events.', details: error.message });
    }
});

// GET /api/events/:eventId - Get details of a specific event by ID
app.get('/api/events/:eventId', async (req, res) => {
    try {
        // 1. Extract eventId from request parameters
        const eventId = req.params.eventId; // Access path parameter using req.params

        // 2. Get database connection from the pool
        const connection = await pool.getConnection();

        try {
            // 3. Construct and execute SQL SELECT query to get event by ID (parameterized query)
            const [rows] = await connection.query(
                'SELECT * FROM events WHERE event_id = ?',
                [eventId]
            );

            // 4. Check if an event was found
            if (rows.length === 0) {
                // If no event found with that ID, return 404 Not Found
                return res.status(404).json({ error: 'Event not found' });
            }

            // 5. If event found, send successful response (200 OK) with the event data
            const event = rows[0]; // Assuming only one event is returned (since event_id is unique)
            res.status(200).json(event);

        } finally {
            connection.release(); // Release connection back to the pool
        }

    } catch (error) {
        // 6. Handle errors (e.g., database errors, invalid eventId format if needed)
        console.error('Error fetching event details:', error);
        res.status(500).json({ error: 'Failed to fetch event details.', details: error.message }); // Send 500 error
    }
});


// PUT /api/events/:eventId - Update an existing event by ID
app.put('/api/events/:eventId', async (req, res) => {
    try {
        // 1. Extract eventId from request parameters
        const eventId = req.params.eventId;

        // 2. Extract updated event data from request body
        const { name, description, location, event_date, category_id } = req.body;

        // 3. Basic validation (optional, but recommended - you can enhance this)
        if (!name && !description && !location && !event_date && !category_id) {
            return res.status(400).json({ error: 'No fields to update provided.' }); // If no fields are sent to update
        }

        // 4. Get database connection from the pool
        const connection = await pool.getConnection();

        try {
            // 5. Construct the UPDATE SQL query dynamically
            let updateQuery = 'UPDATE events SET ';
            const updateValues = [];
            const updates = []; // Array to build SET clauses

            if (category_id !== undefined) { updates.push('category_id = ?'); updateValues.push(category_id); }
            if (name !== undefined) { updates.push('name = ?'); updateValues.push(name); }
            if (description !== undefined) { updates.push('description = ?'); updateValues.push(description); }
            if (location !== undefined) { updates.push('location = ?'); updateValues.push(location); }
            if (event_date !== undefined) { updates.push('event_date = ?'); updateValues.push(event_date); }

            updateQuery += updates.join(', '); // Join the SET clauses with commas
            updateQuery += ' WHERE event_id = ?'; // Add WHERE clause to update specific event
            updateValues.push(eventId); // Add eventId to the values array for the WHERE clause

            // 6. Execute the UPDATE query
            const [result] = await connection.query(updateQuery, updateValues);

            // 7. Check if any rows were affected (if event with given ID existed)
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Event not found' }); // Event not found
            }

            // 8. Fetch the updated event from the database to return in response
            const [updatedEventRows] = await connection.query(
                'SELECT * FROM events WHERE event_id = ?',
                [eventId]
            );
            const updatedEvent = updatedEventRows[0];

            // 9. Send successful response (200 OK) with the updated event data
            res.status(200).json(updatedEvent);

        } finally {
            connection.release(); // Release connection back to the pool
        }

    } catch (error) {
        // 10. Handle errors (e.g., database errors, validation errors)
        console.error('Error updating event:', error);
        res.status(500).json({ error: 'Failed to update event.', details: error.message }); // Send 500 error
    }
});

// DELETE /api/events/:eventId - Delete an event by ID
app.delete('/api/events/:eventId', async (req, res) => {
    try {
        // 1. Extract eventId from request parameters
        const eventId = req.params.eventId;

        // 2. Get database connection from the pool
        const connection = await pool.getConnection();

        try {
            // 3. Construct and execute SQL DELETE query (parameterized query)
            const [result] = await connection.query(
                'DELETE FROM events WHERE event_id = ?',
                [eventId]
            );

            // 4. Check if any rows were affected (if event with given ID existed and was deleted)
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Event not found' }); // Event not found
            }

            // 5. If event was successfully deleted, send 204 No Content response
            res.status(204).send(); // 204 No Content - successful deletion, no response body needed

        } finally {
            connection.release(); // Release connection back to the pool
        }

    } catch (error) {
        // 6. Handle errors (e.g., database errors)
        console.error('Error deleting event:', error);
        res.status(500).json({ error: 'Failed to delete event.', details: error.message }); // Send 500 error
    }
});

// POST /api/categories - Create a new event category
app.post('/api/categories', async (req, res) => {
    try {
        // 1. Extract category name from request body
        const { name } = req.body;

        // 2. Basic input validation (ensure name is provided)
        if (!name) {
            return res.status(400).json({ error: 'Category name is required.' });
        }

        // 3. Get database connection from the pool
        const connection = await pool.getConnection();

        try {
            // 4. Construct and execute SQL INSERT query (using parameterized query)
            const [result] = await connection.query(
                'INSERT INTO eventcategories (category_name) VALUES (?)',
                [name]
            );

            // 5. Get the newly inserted category ID
            const categoryId = result.insertId;

            // 6. Fetch the newly created category from the database to return in response
            const [newCategoryRows] = await connection.query(
                'SELECT * FROM eventcategories WHERE category_id = ?',
                [categoryId]
            );
            const newCategory = newCategoryRows[0]; // Assuming only one category is returned

            // 7. Send successful response (201 Created) with the new category data
            res.status(201).json(newCategory);

        } finally {
            connection.release(); // Release the connection back to the pool
        }

    } catch (error) {
        // 8. Handle errors (e.g., database errors, validation errors)
        console.error('Error creating category:', error);
        res.status(500).json({ error: 'Failed to create category.', details: error.message }); // Send 500 error with a generic message and error details for debugging
    }
});

// GET /api/categories - Get all event categories - WITH PAGINATION
app.get('/api/categories', async (req, res) => {
    console.log(`GET /api/categories - Start processing request, query parameters:`, req.query);

    // 1. Pagination parameters (from query parameters, with defaults)
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const offset = (page - 1) * limit;

    console.log(`GET /api/categories - Pagination parameters: page=${page}, limit=${limit}, offset=${offset}`);

    // 2. Database connection
    try {
        const connection = await pool.getConnection();
        console.log(`GET /api/categories - Database connection acquired`);

        try {
            // --- 4.3.1 (Adapted): Get total count of categories ---
            const countQuery = 'SELECT COUNT(*) AS total_count FROM eventcategories'; // Count for categories
            console.log(`GET /api/categories - SQL query for total count: ${countQuery}`);
            const [countResult] = await connection.query(countQuery);
            const totalCount = countResult[0].total_count;
            console.log(`GET /api/categories - Total categories count: ${totalCount}`);

            // --- 4.3.2 (Adapted): Modified SQL query with LIMIT and OFFSET (for categories) ---
            const categoriesQuery = 'SELECT * FROM eventcategories LIMIT ? OFFSET ?'; // Query for categories
            const sqlParams = [limit, offset];
            console.log(`GET /api/categories - SQL query for categories: ${categoriesQuery} Parameters:`, sqlParams);
            const [rows] = await connection.query(categoriesQuery, sqlParams);

            // --- 4.3.3: Calculate pagination metadata ---
            const totalPages = Math.ceil(totalCount / limit);
            const currentPage = page;
            const perPage = limit;

            // --- 4.3.4: Add pagination metadata to response headers ---
            res.setHeader('X-Total-Count', totalCount);
            res.setHeader('X-Total-Pages', totalPages);
            res.setHeader('X-Current-Page', currentPage);
            res.setHeader('X-Per-Page', perPage);

            // 5. Send response with categories and pagination metadata
            res.status(200).json(rows);
            console.log(`GET /api/categories - Retrieved ${rows.length} categories, 200 response sent (with pagination metadata in headers)`);

        } finally {
            connection.release();
            console.log(`GET /api/categories - Database connection released`);
        }

    } catch (error) {
        console.error('Error fetching categories:', error);
        res.status(500).json({ error: 'Failed to fetch categories.', details: error.message });
    }
});

// GET /api/categories/:categoryId - Get details of a specific category by ID
app.get('/api/categories/:categoryId', async (req, res) => {
    try {
        // 1. Extract categoryId from request parameters
        const categoryId = req.params.categoryId; // Access path parameter using req.params

        // 2. Get database connection from the pool
        const connection = await pool.getConnection();

        try {
            // 3. Construct and execute SQL SELECT query to get category by ID (parameterized query)
            const [rows] = await connection.query(
                'SELECT * FROM eventcategories WHERE category_id = ?',
                [categoryId]
            );

            // 4. Check if a category was found
            if (rows.length === 0) {
                // If no category found with that ID, return 404 Not Found
                return res.status(404).json({ error: 'Category not found' });
            }

            // 5. If category found, send successful response (200 OK) with the category data
            const category = rows[0]; // Assuming only one category is returned (since category_id is unique)
            res.status(200).json(category);

        } finally {
            connection.release(); // Release connection back to the pool
        }

    } catch (error) {
        // 6. Handle errors (e.g., database errors, invalid categoryId format if needed)
        console.error('Error fetching category details:', error);
        res.status(500).json({ error: 'Failed to fetch category details.', details: error.message }); // Send 500 error
    }
});

// PUT /api/categories/:categoryId - Update an existing category by ID
app.put('/api/categories/:categoryId', async (req, res) => {
    try {
        // 1. Extract categoryId from request parameters
        const categoryId = req.params.categoryId;
        console.log(`PUT /api/categories/${categoryId}s - Start processing request`); // Added log

        // 2. Extract updated category data from request body
        const { name, description } = req.body; // Allow updating name and description

        // 3. Basic validation (optional, but recommended - you can enhance this)
        if (!name && !description) {
            return res.status(400).json({ error: 'No fields to update provided.' }); // If no fields are sent to update
        }

        // 4. Get database connection from the pool
        const connection = await pool.getConnection();
        console.log(`PUT /api/categories/${categoryId} - Database connection acquired`); // Added log

        try {
            // 5. Construct the UPDATE SQL query dynamically
            let updateQuery = 'UPDATE eventcategories SET ';
            const updateValues = [];
            const updates = []; // Array to build SET clauses

            if (name !== undefined) { updates.push('category_name = ?'); updateValues.push(name); } // Use category_name here
            if (description !== undefined) { updates.push('description = ?'); updateValues.push(description); }

            updateQuery += updates.join(', '); // Join the SET clauses with commas
            updateQuery += ' WHERE category_id = ?'; // Add WHERE clause to update specific category
            updateValues.push(categoryId); // Add categoryId to the values array for the WHERE clause

            // 6. Execute the UPDATE query
            const [result] = await connection.query(updateQuery, updateValues);
            console.log(`PUT /api/categories/${categoryId} - UPDATE query executed. affectedRows: ${result.affectedRows}`); // Added log

            // 7. Check if any rows were affected (if category with given ID existed)
            if (result.affectedRows === 0) {
                console.log(`PUT /api/categories/${categoryId} - affectedRows is 0, category not found`); // Added log
                return res.status(404).json({ error: 'Category not found' }); // Category not found
            }

            // 8. Fetch the updated category from the database to return in response
            const [updatedCategoryRows] = await connection.query(
                'SELECT * FROM eventcategories WHERE category_id = ?',
                [categoryId]
            );
            const updatedCategory = updatedCategoryRows[0];

            // 9. Send successful response (200 OK) with the updated category data
            res.status(200).json(updatedCategory);
            console.log(`PUT /api/categories/${categoryId} - Successful update, 200 response sent`); // Added log


        } finally {
            connection.release(); // Release connection back to the pool
            console.log(`PUT /api/categories/${categoryId} - Database connection released`); // Added log
        }

    } catch (error) {
        // 10. Handle errors (e.g., database errors, validation errors)
        console.error('Error updating category:', error);
        res.status(500).json({ error: 'Failed to update category.', details: error.message }); // Send 500 error
    }
});

// DELETE /api/categories/:categoryId - Delete a category by ID
app.delete('/api/categories/:categoryId', async (req, res) => {
    console.log(`DELETE /api/categories/${req.params.categoryId} - Start processing request`); // Added log
    try {
        // 1. Extract categoryId from request parameters
        const categoryId = req.params.categoryId;

        // 2. Get database connection from the pool
        const connection = await pool.getConnection();
        console.log(`DELETE /api/categories/${categoryId} - Database connection acquired`); // Added log

        try {
            // 3. Construct and execute SQL DELETE query (parameterized query)
            const [result] = await connection.query(
                'DELETE FROM eventcategories WHERE category_id = ?',
                [categoryId]
            );
            console.log(`DELETE /api/categories/${categoryId} - DELETE query executed. affectedRows: ${result.affectedRows}`); // Added log

            // 4. Check if any rows were affected (if category with given ID existed and was deleted)
            if (result.affectedRows === 0) {
                console.log(`DELETE /api/categories/${categoryId} - affectedRows is 0, category not found`); // Added log
                return res.status(404).json({ error: 'Category not found' }); // Category not found
            }

            // 5. If category was successfully deleted, send 204 No Content response
            res.status(204).send(); // 204 No Content - successful deletion, no response body needed
            console.log(`DELETE /api/categories/${categoryId} - Successful deletion, 204 response sent`); // Added log

        } finally {
            connection.release(); // Release connection back to the pool
            console.log(`DELETE /api/categories/${categoryId} - Database connection released`); // Added log
        }

    } catch (error) {
        // 6. Handle errors (e.g., database errors)
        console.error('Error deleting category:', error);
        res.status(500).json({ error: 'Failed to delete category.', details: error.message }); // Send 500 error
    }
});

// ------------------- Dashboard API Endpoints -------------------

// GET /api/dashboard/stats - Get dashboard statistics
app.get('/api/dashboard/stats', authenticateJWT, async (req, res) => {
    try {
        const connection = await pool.getConnection();
        try {
            // Get stats for the dashboard
            const [stats] = await connection.query(`
                SELECT 
                    (SELECT COUNT(*) FROM events) AS totalEvents,
                    (SELECT COUNT(*) FROM events WHERE event_date >= CURDATE()) AS upcomingEvents,
                    (SELECT COUNT(*) FROM events WHERE event_date < CURDATE()) AS completedEvents,
                    (SELECT SUM(attendees) FROM events) AS totalAttendees
            `);

            res.status(200).json(stats[0]);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching dashboard stats:', error);
        res.status(500).json({ error: 'Failed to fetch dashboard statistics.', details: error.message });
    }
});

// GET /api/events/upcoming - Get upcoming events
app.get('/api/events/upcoming', authenticateJWT, async (req, res) => {
    try {
        const connection = await pool.getConnection();
        try {
            // Get upcoming events (limited to next 5)
            const [events] = await connection.query(`
                SELECT * FROM events 
                WHERE event_date >= CURDATE()
                ORDER BY event_date ASC
                LIMIT 5
            `);

            res.status(200).json(events);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching upcoming events:', error);
        res.status(500).json({ error: 'Failed to fetch upcoming events.', details: error.message });
    }
});

// GET /api/events/past - Get past events with review info
app.get('/api/events/past', authenticateJWT, async (req, res) => {
    try {
        const connection = await pool.getConnection();
        try {
            // Get past events with review count and average rating
            const [events] = await connection.query(`
                SELECT e.*, 
                    (SELECT COUNT(*) FROM reviews r WHERE r.event_id = e.event_id) AS review_count,
                    (SELECT AVG(rating) FROM reviews r WHERE r.event_id = e.event_id) AS avg_rating
                FROM events e
                WHERE e.event_date < CURDATE()
                ORDER BY e.event_date DESC
                LIMIT 10
            `);

            res.status(200).json(events);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching past events:', error);
        res.status(500).json({ error: 'Failed to fetch past events.', details: error.message });
    }
});

// GET /api/events/:eventId/reviews - Get reviews for a specific event
app.get('/api/events/:eventId/reviews', authenticateJWT, async (req, res) => {
    try {
        const eventId = req.params.eventId;
        const connection = await pool.getConnection();

        try {
            // Get all reviews for this event with username
            const [reviews] = await connection.query(`
                SELECT r.*, u.username 
                FROM reviews r
                JOIN users u ON r.user_id = u.user_id
                WHERE r.event_id = ?
                ORDER BY r.created_at DESC
            `, [eventId]);

            res.status(200).json(reviews);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching event reviews:', error);
        res.status(500).json({ error: 'Failed to fetch event reviews.', details: error.message });
    }
});

// POST /api/events/:eventId/reviews - Add a review to an event
app.post('/api/events/:eventId/reviews', authenticateJWT, async (req, res) => {
    try {
        const eventId = req.params.eventId;
        const userId = req.user.userId; // Get from JWT token
        const { review_text, rating } = req.body;

        // Validate rating is between 1-5
        if (!rating || rating < 1 || rating > 5) {
            return res.status(400).json({ error: 'Rating must be between 1 and 5.' });
        }

        const connection = await pool.getConnection();
        try {
            // Check if event exists
            const [eventCheck] = await connection.query(
                'SELECT * FROM events WHERE event_id = ?',
                [eventId]
            );

            if (eventCheck.length === 0) {
                return res.status(404).json({ error: 'Event not found.' });
            }

            // Check if user already reviewed this event
            const [existingReview] = await connection.query(
                'SELECT * FROM reviews WHERE event_id = ? AND user_id = ?',
                [eventId, userId]
            );

            if (existingReview.length > 0) {
                return res.status(409).json({ error: 'You have already reviewed this event.' });
            }

            // Create new review
            const [result] = await connection.query(
                'INSERT INTO reviews (event_id, user_id, review_text, rating) VALUES (?, ?, ?, ?)',
                [eventId, userId, review_text, rating]
            );

            // Get the newly created review
            const [newReview] = await connection.query(
                'SELECT r.*, u.username FROM reviews r JOIN users u ON r.user_id = u.user_id WHERE r.review_id = ?',
                [result.insertId]
            );

            res.status(201).json(newReview[0]);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error creating review:', error);
        res.status(500).json({ error: 'Failed to create review.', details: error.message });
    }
});

// ------------------- Review API Endpoints -------------------

// PUT /api/reviews/:reviewId - Update a review
app.put('/api/reviews/:reviewId', authenticateJWT, async (req, res) => {
    try {
        const reviewId = req.params.reviewId;
        const userId = req.user.userId;
        const { review_text, rating } = req.body;

        // Validate rating is between 1-5
        if (rating !== undefined && (rating < 1 || rating > 5)) {
            return res.status(400).json({ error: 'Rating must be between 1 and 5.' });
        }

        const connection = await pool.getConnection();
        try {
            // Check if review exists and belongs to the user
            const [reviewCheck] = await connection.query(
                'SELECT * FROM reviews WHERE review_id = ?',
                [reviewId]
            );

            if (reviewCheck.length === 0) {
                return res.status(404).json({ error: 'Review not found.' });
            }

            // Only allow users to edit their own reviews (unless admin)
            if (reviewCheck[0].user_id !== userId) {
                return res.status(403).json({ error: 'You can only edit your own reviews.' });
            }

            // Update the review
            const updateFields = [];
            const updateValues = [];

            if (review_text !== undefined) {
                updateFields.push('review_text = ?');
                updateValues.push(review_text);
            }

            if (rating !== undefined) {
                updateFields.push('rating = ?');
                updateValues.push(rating);
            }

            if (updateFields.length === 0) {
                return res.status(400).json({ error: 'No fields to update.' });
            }

            // Add review_id to values array for WHERE clause
            updateValues.push(reviewId);

            await connection.query(
                `UPDATE reviews SET ${updateFields.join(', ')} WHERE review_id = ?`,
                updateValues
            );

            // Get the updated review
            const [updatedReview] = await connection.query(
                'SELECT r.*, u.username FROM reviews r JOIN users u ON r.user_id = u.user_id WHERE r.review_id = ?',
                [reviewId]
            );

            res.status(200).json(updatedReview[0]);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error updating review:', error);
        res.status(500).json({ error: 'Failed to update review.', details: error.message });
    }
});

// DELETE /api/reviews/:reviewId - Delete a review
app.delete('/api/reviews/:reviewId', authenticateJWT, async (req, res) => {
    try {
        const reviewId = req.params.reviewId;
        const userId = req.user.userId;

        const connection = await pool.getConnection();
        try {
            // Check if review exists and belongs to the user
            const [reviewCheck] = await connection.query(
                'SELECT * FROM reviews WHERE review_id = ?',
                [reviewId]
            );

            if (reviewCheck.length === 0) {
                return res.status(404).json({ error: 'Review not found.' });
            }

            // Only allow users to delete their own reviews (unless admin)
            if (reviewCheck[0].user_id !== userId && req.user.role !== 'admin') {
                return res.status(403).json({ error: 'You can only delete your own reviews.' });
            }

            // Delete the review
            await connection.query(
                'DELETE FROM reviews WHERE review_id = ?',
                [reviewId]
            );

            res.status(204).send();
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error deleting review:', error);
        res.status(500).json({ error: 'Failed to delete review.', details: error.message });
    }
});

// GET /api/reviews - Get all reviews with filtering and sorting
app.get('/api/reviews', authenticateJWT, async (req, res) => {
    try {
        const { event_id, user_id, min_rating, max_rating, sort_by, sort_order, status } = req.query;
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 10;
        const offset = (page - 1) * limit;

        let query = `
            SELECT r.*, u.username, e.name as event_name
            FROM reviews r
            JOIN users u ON r.user_id = u.user_id
            JOIN events e ON r.event_id = e.event_id
            WHERE 1=1
        `;

        const queryParams = [];

        // Apply filters
        if (event_id) {
            query += ' AND r.event_id = ?';
            queryParams.push(event_id);
        }

        if (user_id) {
            query += ' AND r.user_id = ?';
            queryParams.push(user_id);
        }

        if (min_rating) {
            query += ' AND r.rating >= ?';
            queryParams.push(min_rating);
        }

        if (max_rating) {
            query += ' AND r.rating <= ?';
            queryParams.push(max_rating);
        }

        if (status && status !== 'all') {
            query += ' AND r.moderation_status = ?';
            queryParams.push(status);
        }

        // Apply sorting
        const validSortFields = ['created_at', 'rating', 'event_id', 'user_id'];
        const validSortOrders = ['asc', 'desc'];

        let orderBy = ' ORDER BY r.created_at DESC';

        if (sort_by && validSortFields.includes(sort_by)) {
            const direction = sort_order && validSortOrders.includes(sort_order.toLowerCase())
                ? sort_order.toUpperCase()
                : 'DESC';
            orderBy = ` ORDER BY r.${sort_by} ${direction}`;
        }

        query += orderBy;

        // Apply pagination
        query += ' LIMIT ? OFFSET ?';
        queryParams.push(limit, offset);

        const connection = await pool.getConnection();
        try {
            // Get total count for pagination metadata
            let countQuery = `
                SELECT COUNT(*) AS total
                FROM reviews r
                JOIN users u ON r.user_id = u.user_id
                JOIN events e ON r.event_id = e.event_id
                WHERE 1=1
            `;

            const countParams = [];

            if (event_id) {
                countQuery += ' AND r.event_id = ?';
                countParams.push(event_id);
            }

            if (user_id) {
                countQuery += ' AND r.user_id = ?';
                countParams.push(user_id);
            }

            if (min_rating) {
                countQuery += ' AND r.rating >= ?';
                countParams.push(min_rating);
            }

            if (max_rating) {
                countQuery += ' AND r.rating <= ?';
                countParams.push(max_rating);
            }

            if (status && status !== 'all') {
                countQuery += ' AND r.moderation_status = ?';
                countParams.push(status);
            }

            const [countResult] = await connection.query(countQuery, countParams);
            const total = countResult[0].total;

            // Execute main query
            const [reviews] = await connection.query(query, queryParams);

            // Set pagination headers
            res.setHeader('X-Total-Count', total);
            res.setHeader('X-Total-Pages', Math.ceil(total / limit));
            res.setHeader('X-Current-Page', page);
            res.setHeader('X-Per-Page', limit);

            res.status(200).json(reviews);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching reviews:', error);
        res.status(500).json({ error: 'Failed to fetch reviews.', details: error.message });
    }
});

// GET /api/reviews/analytics - Get review analytics
app.get('/api/reviews/analytics', authenticateJWT, async (req, res) => {
    try {
        const { event_id } = req.query;

        const connection = await pool.getConnection();
        try {
            let query = `
                SELECT 
                    COUNT(*) as total_reviews,
                    AVG(rating) as average_rating,
                    COUNT(CASE WHEN rating = 5 THEN 1 END) as five_star,
                    COUNT(CASE WHEN rating = 4 THEN 1 END) as four_star,
                    COUNT(CASE WHEN rating = 3 THEN 1 END) as three_star,
                    COUNT(CASE WHEN rating = 2 THEN 1 END) as two_star,
                    COUNT(CASE WHEN rating = 1 THEN 1 END) as one_star,
                    COUNT(CASE WHEN rating >= 4 THEN 1 END) as positive_reviews,
                    COUNT(CASE WHEN rating <= 2 THEN 1 END) as negative_reviews
                FROM reviews
            `;

            const queryParams = [];

            if (event_id) {
                query += ' WHERE event_id = ?';
                queryParams.push(event_id);
            }

            const [analytics] = await connection.query(query, queryParams);

            // Get recent reviews
            let recentQuery = `
                SELECT r.*, u.username
                FROM reviews r
                JOIN users u ON r.user_id = u.user_id
            `;

            if (event_id) {
                recentQuery += ' WHERE r.event_id = ?';
            }

            recentQuery += ' ORDER BY r.created_at DESC LIMIT 5';

            const [recentReviews] = await connection.query(recentQuery, event_id ? [event_id] : []);

            res.status(200).json({
                analytics: analytics[0],
                recentReviews
            });
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching review analytics:', error);
        res.status(500).json({ error: 'Failed to fetch review analytics.', details: error.message });
    }
});

// ------------------- User Profile API Endpoints -------------------

// GET /api/users/profile - Make sure this uses the correct User fields
app.get('/api/users/profile', authenticateJWT, async (req, res) => {
    try {
        const userId = req.user.userId;

        const connection = await pool.getConnection();
        try {
            // Get user profile data - Make sure column names match your database
            const [users] = await connection.query(
                'SELECT user_id, username, email, bio, profile_picture, created_at, role FROM users WHERE user_id = ?',
                [userId]
            );

            if (users.length === 0) {
                return res.status(404).json({ error: 'User not found' });
            }

            res.status(200).json(users[0]);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching user profile:', error);
        res.status(500).json({ error: 'Failed to fetch user profile', details: error.message });
    }
});

// PUT /api/users/profile - Update current user's profile
app.put('/api/users/profile', authenticateJWT, async (req, res) => {
    try {
        const userId = req.user.userId;
        const { email, bio, location, avatar_url } = req.body;

        // Validate email if provided
        if (email && !email.includes('@')) {
            return res.status(400).json({ error: 'Invalid email format' });
        }

        const connection = await pool.getConnection();
        try {
            // Build update query dynamically based on provided fields
            let updateQuery = 'UPDATE users SET ';
            const updateValues = [];
            const updates = [];

            if (email !== undefined) { updates.push('email = ?'); updateValues.push(email); }
            if (bio !== undefined) { updates.push('bio = ?'); updateValues.push(bio); }
            if (location !== undefined) { updates.push('location = ?'); updateValues.push(location); }
            if (avatar_url !== undefined) { updates.push('avatar_url = ?'); updateValues.push(avatar_url); }

            if (updates.length === 0) {
                return res.status(400).json({ error: 'No fields to update provided' });
            }

            updateQuery += updates.join(', ');
            updateQuery += ' WHERE user_id = ?';
            updateValues.push(userId);

            // Execute update query
            const [result] = await connection.query(updateQuery, updateValues);

            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'User not found' });
            }

            // Get updated user profile
            const [users] = await connection.query(
                'SELECT user_id, username, email, created_at, bio, location, avatar_url, role FROM users WHERE user_id = ?',
                [userId]
            );

            res.status(200).json(users[0]);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error updating user profile:', error);
        res.status(500).json({ error: 'Failed to update user profile', details: error.message });
    }
});

// PUT /api/users/password - Change user's password
app.put('/api/users/password', authenticateJWT, async (req, res) => {
    try {
        const userId = req.user.userId;
        const { currentPassword, newPassword } = req.body;

        if (!currentPassword || !newPassword) {
            return res.status(400).json({ error: 'Current password and new password are required' });
        }

        if (newPassword.length < 6) {
            return res.status(400).json({ error: 'New password must be at least 6 characters long' });
        }

        const connection = await pool.getConnection();
        try {
            // Get current user data to verify password
            const [users] = await connection.query(
                'SELECT password_hash FROM users WHERE user_id = ?',
                [userId]
            );

            if (users.length === 0) {
                return res.status(404).json({ error: 'User not found' });
            }

            // Verify current password
            const passwordMatch = await bcrypt.compare(currentPassword, users[0].password_hash);
            if (!passwordMatch) {
                return res.status(401).json({ error: 'Current password is incorrect' });
            }

            // Hash new password
            const saltRounds = 10;
            const newPasswordHash = await bcrypt.hash(newPassword, saltRounds);

            // Update password
            const [result] = await connection.query(
                'UPDATE users SET password_hash = ? WHERE user_id = ?',
                [newPasswordHash, userId]
            );

            res.status(200).json({ message: 'Password updated successfully' });
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error updating password:', error);
        res.status(500).json({ error: 'Failed to update password', details: error.message });
    }
});

// GET /api/users/activities - Get user's recent activities
app.get('/api/users/activities', authenticateJWT, async (req, res) => {
    try {
        const userId = req.user.userId;

        const connection = await pool.getConnection();
        try {
            // Get user's recent events created
            const [createdEvents] = await connection.query(
                `SELECT 'event_created' AS activity_type, event_id, name, event_date, created_at 
                FROM events 
                WHERE user_id = ? 
                ORDER BY created_at DESC LIMIT 5`,
                [userId]
            );

            // Get user's recent reviews
            const [submittedReviews] = await connection.query(
                `SELECT 'review_submitted' AS activity_type, r.review_id, r.event_id, e.name, r.rating, r.created_at 
                FROM reviews r
                JOIN events e ON r.event_id = e.event_id
                WHERE r.user_id = ? 
                ORDER BY r.created_at DESC LIMIT 5`,
                [userId]
            );

            // Combine and sort activities
            const activities = [...createdEvents, ...submittedReviews]
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                .slice(0, 10);

            res.status(200).json(activities);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching user activities:', error);
        res.status(500).json({ error: 'Failed to fetch user activities', details: error.message });
    }
});

// ------------------- Calendar API Endpoints -------------------

// GET /api/calendar/events - Get events within a date range
app.get('/api/calendar/events', authenticateJWT, async (req, res) => {
    try {
        // Get date range from query parameters
        const { start_date, end_date, category_id } = req.query;

        // Validate dates
        if (!start_date || !end_date) {
            return res.status(400).json({ error: 'Start date and end date are required' });
        }

        const connection = await pool.getConnection();
        try {
            let query = `
                SELECT e.*, c.category_name 
                FROM events e
                LEFT JOIN eventcategories c ON e.category_id = c.category_id
                WHERE e.event_date BETWEEN ? AND ?
            `;

            const queryParams = [start_date, end_date];

            // Add category filter if provided
            if (category_id && category_id !== 'all') {
                query += ' AND e.category_id = ?';
                queryParams.push(category_id);
            }

            // Order by date
            query += ' ORDER BY e.event_date ASC';

            const [events] = await connection.query(query, queryParams);

            res.status(200).json(events);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching calendar events:', error);
        res.status(500).json({ error: 'Failed to fetch calendar events', details: error.message });
    }
});

// GET /api/calendar/events/:date - Get events for a specific date
app.get('/api/calendar/events/:date', authenticateJWT, async (req, res) => {
    try {
        const date = req.params.date; // Format: YYYY-MM-DD

        if (!date) {
            return res.status(400).json({ error: 'Date parameter is required' });
        }

        const connection = await pool.getConnection();
        try {
            // Get events for the specific date 
            // Using DATE() to extract just the date part from event_date
            const [events] = await connection.query(`
                SELECT e.*, c.category_name 
                FROM events e
                LEFT JOIN eventcategories c ON e.category_id = c.category_id
                WHERE DATE(e.event_date) = DATE(?)
                ORDER BY e.event_date ASC
            `, [date]);

            res.status(200).json(events);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching events for date:', error);
        res.status(500).json({ error: 'Failed to fetch events for date', details: error.message });
    }
});

// GET /api/calendar/dates-with-events - Get all dates that have events within a month
app.get('/api/calendar/dates-with-events', authenticateJWT, async (req, res) => {
    try {
        // Get year and month from query parameters (e.g., year=2024&month=7 for July 2024)
        const { year, month } = req.query;

        if (!year || !month) {
            return res.status(400).json({ error: 'Year and month parameters are required' });
        }

        const connection = await pool.getConnection();
        try {
            // Extract dates with events for the specified month
            // Use DATE() to get just the date part
            const [results] = await connection.query(`
                SELECT DISTINCT DATE(event_date) as date
                FROM events
                WHERE YEAR(event_date) = ? 
                AND MONTH(event_date) = ?
                ORDER BY date ASC
            `, [year, month]);

            // Extract just the dates
            const dates = results.map(row => row.date);

            res.status(200).json(dates);
        } finally {
            connection.release();
        }
    } catch (error) {
        console.error('Error fetching dates with events:', error);
        res.status(500).json({ error: 'Failed to fetch dates with events', details: error.message });
    }
});

app.get('/', (req, res) => {
    res.status(200).send('Railway Deployment Healthy');
});

app.listen(port, () => {
    console.log(`Server is running on port http://localhost:${port}`);
    testDatabaseConnection(); // Test database connection
});

================
File: evently_db_backup.sql
================
-- MySQL dump 10.13  Distrib 9.2.0, for Win64 (x86_64)
--
-- Host: localhost    Database: evently_db
-- ------------------------------------------------------
-- Server version	9.2.0

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `eventcategories`
--

DROP TABLE IF EXISTS `eventcategories`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `eventcategories` (
  `category_id` int unsigned NOT NULL AUTO_INCREMENT,
  `category_name` varchar(100) NOT NULL,
  `description` text,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`category_id`),
  UNIQUE KEY `category_name` (`category_name`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `eventcategories`
--

LOCK TABLES `eventcategories` WRITE;
/*!40000 ALTER TABLE `eventcategories` DISABLE KEYS */;
INSERT INTO `eventcategories` VALUES (1,'Technology',NULL,'2025-02-26 09:44:58','2025-02-26 09:44:58'),(2,'Art',NULL,'2025-02-26 09:45:18','2025-02-26 09:45:18'),(3,'Music',NULL,'2025-02-26 09:45:31','2025-02-26 09:45:31'),(4,'Food',NULL,'2025-02-26 09:45:46','2025-02-26 09:45:46'),(5,'Sports',NULL,'2025-02-26 09:46:08','2025-02-26 09:46:08');
/*!40000 ALTER TABLE `eventcategories` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `events`
--

DROP TABLE IF EXISTS `events`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `events` (
  `event_id` int NOT NULL AUTO_INCREMENT,
  `user_id` int unsigned NOT NULL,
  `name` varchar(255) NOT NULL,
  `description` text,
  `event_date` datetime NOT NULL,
  `location` varchar(255) DEFAULT NULL,
  `event_type` varchar(100) DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `category_id` int unsigned NOT NULL,
  PRIMARY KEY (`event_id`),
  KEY `user_id` (`user_id`),
  KEY `fk_events_categories` (`category_id`),
  CONSTRAINT `events_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`user_id`),
  CONSTRAINT `fk_events_categories` FOREIGN KEY (`category_id`) REFERENCES `eventcategories` (`category_id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `events`
--

LOCK TABLES `events` WRITE;
/*!40000 ALTER TABLE `events` DISABLE KEYS */;
INSERT INTO `events` VALUES (1,1,'Annual Tech Conference 2025','Join us for the largest tech conference of the year in 2025! Speakers, workshops, and networking opportunities.','2025-03-15 09:00:00','Convention Center, New York',NULL,'2025-02-26 10:10:18','2025-02-26 10:10:18',1),(2,1,'Modern Art Exhibition Opening 2025','Experience the opening night of the \'Visions of Tomorrow 2025\' art exhibition. Meet talented artists and immerse yourself in contemporary masterpieces.','2025-03-22 18:00:00','City Art Gallery, London',NULL,'2025-02-26 10:16:56','2025-02-26 10:16:56',2),(3,1,'Indie Rock Live Concert 2025','Get ready for an unforgettable night of indie rock music with headliners \'The Pioneers\' and rising stars \'Electric Dreams\' in 2025.','2025-03-29 20:30:00','Music Hall, Berlin',NULL,'2025-02-26 10:17:07','2025-02-26 10:17:07',3),(4,1,'International Food Festival 2025','Embark on a culinary journey around the world in 2025 at our International Food Festival! Taste exquisite dishes from over 30 countries, enjoy live cooking demonstrations, and family-friendly fun.','2025-04-05 11:00:00','Central Park, Paris',NULL,'2025-02-26 10:17:19','2025-02-26 10:17:19',4),(5,1,'Professional Basketball Game 2025','Experience the thrill of professional basketball as the \'City Eagles\' clash with the \'Downtown Sharks\' in a highly anticipated match in 2025.','2025-04-12 19:00:00','Sports Arena, Chicago',NULL,'2025-02-26 10:17:37','2025-02-26 10:17:37',5),(6,1,'Future of Tech Summit 2024','A retrospective look at the Future of Tech Summit held in October 2024. Discussions on AI, Blockchain, and more.','2024-10-12 09:00:00','Tech Convention Center, San Francisco',NULL,'2025-02-28 09:21:06','2025-02-28 09:21:06',1),(7,1,'Rock Legends Reunion Concert - 2024','A throwback to the amazing Rock Legends Reunion concert from August 2024 featuring iconic rock bands.','2024-08-25 19:30:00','Stadium Arena, London',NULL,'2025-02-28 09:25:29','2025-02-28 09:25:29',3),(8,1,'Championship Basketball Finals - 2024','Relive the excitement of the Championship Basketball Finals game from June 2024.','2024-06-15 17:00:00','National Sports Center, Chicago',NULL,'2025-02-28 09:25:40','2025-02-28 09:25:40',4),(9,1,'Summer Flavors Food Festival 2024','A delicious memory of the Summer Flavors Food Festival held in July 2024, showcasing diverse cuisines.','2024-07-04 12:00:00','Downtown Festival Park, New York',NULL,'2025-02-28 09:25:51','2025-02-28 09:25:51',5),(10,1,'Abstract Visions Art Show - 2024','Remember the Abstract Visions art exhibition that showcased modern abstract art in September 2024.','2024-09-18 11:00:00','Modern Art Gallery, Paris',NULL,'2025-02-28 09:28:13','2025-02-28 09:28:13',2);
/*!40000 ALTER TABLE `events` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `reviews`
--

DROP TABLE IF EXISTS `reviews`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `reviews` (
  `review_id` int NOT NULL AUTO_INCREMENT,
  `event_id` int NOT NULL,
  `user_id` int unsigned NOT NULL,
  `review_text` text,
  `rating` int unsigned NOT NULL,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`review_id`),
  KEY `event_id` (`event_id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `reviews_ibfk_1` FOREIGN KEY (`event_id`) REFERENCES `events` (`event_id`) ON DELETE CASCADE,
  CONSTRAINT `reviews_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE,
  CONSTRAINT `reviews_chk_1` CHECK (((`rating` >= 1) and (`rating` <= 5)))
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `reviews`
--

LOCK TABLES `reviews` WRITE;
/*!40000 ALTER TABLE `reviews` DISABLE KEYS */;
/*!40000 ALTER TABLE `reviews` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `users` (
  `user_id` int unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL,
  `email` varchar(255) NOT NULL,
  `password_hash` varchar(255) NOT NULL,
  `registration_date` datetime DEFAULT CURRENT_TIMESTAMP,
  `profile_picture` varchar(255) DEFAULT NULL,
  `bio` text,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `role` varchar(20) NOT NULL DEFAULT 'user',
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `username` (`username`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES (1,'Mihlali','Mihlali@example.com','$2b$10$tTaUdJgmEJsyjYWSVgdbdu.BRQyHkRwpU2A5NvxF5IswpcQ0C1B8K','2025-02-26 11:35:32',NULL,'Peas','2025-02-26 09:35:32','2025-03-03 12:19:16','user'),(2,'Mihle','Mihle@example.com','$2b$10$56.QlziuOxhUGeqhjMI2i.8iuj8RK24WNf6rEgu7rP0y5C4rBguo6','2025-02-26 12:22:04',NULL,'Chilled guy.','2025-02-26 10:22:04','2025-02-28 08:01:08','user'),(3,'Bukho','Bukho@example.com','$2b$10$Qobu77Z1J9znXaD/bQyXTOn97Y2PZAPGH.lwLMa7OJlR5ocxNa/kK','2025-02-27 10:37:18',NULL,NULL,'2025-02-27 08:37:18','2025-02-27 08:37:18','user'),(4,'admin_user','admin@example.com','$2b$10$ju.xfbn5sAHWgYRvYxvqiuAlx.81S0yr/bjvgTV1M4mTGYabiajUC','2025-03-03 16:13:52',NULL,NULL,'2025-03-03 14:13:52','2025-03-03 14:13:52','admin'),(5,'Sihle','sihle@gmail.com','$2b$10$L4oCg5jxGEXzen61IqJLf.MaGom.7c/C245.Kebt3vG2fZnASB8oK','2025-03-03 17:07:07',NULL,NULL,'2025-03-03 15:07:07','2025-03-03 15:07:07','admin'),(6,'Boa','boa@gmail.com','$2b$10$yvR3RiHWRt6b5Semqld6C.FVOu1V0BD/DREg13iH2TBFJbEYBbWuG','2025-03-03 17:08:01',NULL,NULL,'2025-03-03 15:08:01','2025-03-03 15:08:01','user');
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-03-04 16:57:35

================
File: frontend/.env
================
VITE_API_URL=https://evently-production-cd21.up.railway.app

================
File: frontend/.env  .development
================
VITE_API_URL=http://localhost:5000

================
File: frontend/.env.production
================
VITE_API_URL=https://evently-production-cd21.up.railway.app

================
File: frontend/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: frontend/.npmrc
================
legacy-peer-deps=true

================
File: frontend/eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

================
File: frontend/generate-env.js
================
// generate-env.js
const fs = require('fs');

// Generate a JavaScript file with the environment variables
fs.writeFileSync(
  './public/env-config.js',
  `window.ENV_CONFIG = ${JSON.stringify({
    API_URL: process.env.REACT_APP_API_URL || 'http://localhost:5000'
  })};`
);

================
File: frontend/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: frontend/package.json
================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
  "@emotion/react": "^11.11.1",
  "@emotion/styled": "^11.11.0",
  "@mui/icons-material": "^5.14.19",
  "@mui/material": "^5.14.20",
  "@mui/x-date-pickers": "^6.0.0",
  "react": "^18.2.0",
  "react-dom": "^18.2.0",
  "react-router-dom": "^6.20.1",
  "date-fns": "^2.30.0"
  },
  
  "devDependencies": {
    "@eslint/js": "^9.19.0",
    "@types/react": "^19.0.8",
    "@types/react-dom": "^19.0.3",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.19.0",
    "eslint-plugin-react": "^7.37.4",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.18",
    "globals": "^15.14.0",
    "vite": "^6.1.0"
  }
}

================
File: frontend/public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: frontend/README.md
================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

================
File: frontend/src/App.css
================
#root {
  width: 100%;
  margin: 0;
  padding: 0;
  /* Removed max-width and center alignment */
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: frontend/src/App.jsx
================
import React, { useState, useEffect } from 'react';
import Dashboard from './components/Dashboard';
import LandingPage from './components/LandingPage';
import EventsList from './components/EventsList';
import UserProfile from './components/UserProfile';
import SimpleEventCalendar from './components/SimpleEventCalendar';


// Material UI Components
import {
    Container, Typography, Box, AppBar, Toolbar, IconButton, CssBaseline,
    useTheme, ThemeProvider, createTheme, Avatar, Button, Drawer, List,
    ListItem, ListItemIcon, ListItemText, Divider, Chip
} from '@mui/material';
import {
    Brightness4, Brightness7, Dashboard as DashboardIcon,
    EventNote, AccountCircle, Menu as MenuIcon, CalendarMonth,
    Event, Comment
} from '@mui/icons-material';

function App() {
    const [isLoggedIn, setIsLoggedIn] = useState(false);
    const [username, setUsername] = useState(null);
    const [darkMode, setDarkMode] = useState(false);
    const [drawerOpen, setDrawerOpen] = useState(false);
    const [activePage, setActivePage] = useState('dashboard');
    const [userRole, setUserRole] = useState('user');

    useEffect(() => {
        console.log('API URL:', import.meta.env.VITE_API_URL || 'http://localhost:5000');
        const token = localStorage.getItem('authToken');
        const storedUsername = localStorage.getItem('username');
        
        if (token) {
            try {
                // Detailed token decoding
                const payload = token.split('.')[1];
                const decodedPayload = JSON.parse(atob(payload));
    
                console.group('ðŸ” Token Inspection');
                console.log('Payload Contents:', decodedPayload);
    
                setIsLoggedIn(true);
                setUsername(storedUsername);
                // The role might be missing from your token payload, so handle that case
                if (decodedPayload.role) {
                    setUserRole(decodedPayload.role);
                }
    
                console.groupEnd();
            } catch (error) {
                console.error('Token Decoding Error:', error);
                // Clear invalid token
                localStorage.removeItem('authToken');
                setIsLoggedIn(false);
            }
        }
    }, []);

    // Add event listener for navigation events
    useEffect(() => {
        const handleNavigation = (event) => {
            if (event.detail && typeof event.detail === 'string') {
                setActivePage(event.detail);
            }
        };

        window.addEventListener('navigate', handleNavigation);

        return () => {
            window.removeEventListener('navigate', handleNavigation);
        };
    }, []);

    const handleLoginSuccess = (loggedInUsername, role = 'user') => {
        setIsLoggedIn(true);
        setUsername(loggedInUsername);
        setUserRole(role);
        localStorage.setItem('username', loggedInUsername);
    };

    const handleLogout = () => {
        localStorage.removeItem('authToken');
        localStorage.removeItem('username');
        setIsLoggedIn(false);
        setUsername(null);
        setUserRole(null);
        setActivePage('dashboard');
        console.log('JWT token removed from localStorage. User logged out.');
    };

    const theme = createTheme({
        palette: {
            mode: darkMode ? 'dark' : 'light',
            primary: {
                main: darkMode ? '#90caf9' : '#3f51b5'
            },
            secondary: {
                main: darkMode ? '#f48fb1' : '#f50057'
            },
            background: {
                default: darkMode ? '#303030' : '#f5f5f5',
                paper: darkMode ? '#424242' : '#ffffff',
            },
        },
        typography: {
            fontFamily: '"Poppins", "Roboto", "Helvetica", "Arial", sans-serif',
            h1: {
                fontWeight: 600,
            },
            h2: {
                fontWeight: 500,
            },
            h6: {
                fontWeight: 500,
            },
        },
        shape: {
            borderRadius: 8,
        },
        components: {
            MuiButton: {
                styleOverrides: {
                    root: {
                        textTransform: 'none',
                        fontWeight: 500,
                    },
                },
            },
            MuiPaper: {
                styleOverrides: {
                    root: {
                        boxShadow: darkMode ? '0px 3px 15px rgba(0,0,0,0.2)' : '0px 3px 15px rgba(0,0,0,0.1)',
                    },
                },
            },
        },
    });

    const toggleDrawer = () => {
        setDrawerOpen(!drawerOpen);
    };

    const navigateTo = (page) => {
        setActivePage(page);
        setDrawerOpen(false);
    };

    const renderAppContent = () => {
        if (activePage === 'dashboard') {
            return (
                <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%' }}>
                    <Dashboard username={username} />
                </Box>
            );
        } else if (activePage === 'events') {
            return <EventsList />;
        } else if (activePage === 'calendar') {
            return <SimpleEventCalendar />;
        } else if (activePage === 'profile') {
            return <UserProfile />;
        } else {
            // Fallback to dashboard if page not found or not authorized
            return (
                <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%' }}>
                    <Dashboard username={username} />
                </Box>
            );
        }
    };

    const sidebarItems = [
        { text: 'Dashboard', icon: <DashboardIcon />, page: 'dashboard' },
        { text: 'Events', icon: <EventNote />, page: 'events' },
        { text: 'Calendar', icon: <CalendarMonth />, page: 'calendar' },
        { text: 'Profile', icon: <AccountCircle />, page: 'profile' },
    ];

    
    return (
        <ThemeProvider theme={theme}>
            <CssBaseline />
            {isLoggedIn && (
                <>
                    <AppBar position="static" color="primary" elevation={0}>
                        <Toolbar sx={{ justifyContent: 'space-between' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <IconButton
                                    edge="start"
                                    color="inherit"
                                    aria-label="menu"
                                    onClick={toggleDrawer}
                                    sx={{ mr: 2 }}
                                >
                                    <MenuIcon />
                                </IconButton>
                                <Typography variant="h5" component="div" sx={{ fontWeight: 'bold' }}>
                                    Evently
                                </Typography>
                            </Box>
                            <Box>
                                <IconButton onClick={() => setDarkMode(!darkMode)} color="inherit">
                                    {darkMode ? <Brightness7 /> : <Brightness4 />}
                                </IconButton>
                                <Button
                                    color="inherit"
                                    onClick={() => navigateTo('profile')}
                                    startIcon={
                                        <Avatar
                                            sx={{ width: 24, height: 24, bgcolor: 'primary.contrastText' }}
                                        >
                                            {username ? username[0].toUpperCase() : 'U'}
                                        </Avatar>
                                    }
                                >
                                    {username || 'User'}
                                </Button>
                            </Box>
                        </Toolbar>
                    </AppBar>

                    <Drawer
                        anchor="left"
                        open={drawerOpen}
                        onClose={toggleDrawer}
                    >
                        <Box sx={{ width: 250 }} role="presentation">
                            <Box sx={{ p: 2, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                <Typography variant="h6" component="div" sx={{ fontWeight: 'bold' }}>
                                    Evently
                                </Typography>
                            </Box>
                            <Divider />
                            <List>
                                {sidebarItems.map((item) => (
                                    <ListItem
                                        button
                                        key={item.text}
                                        onClick={() => navigateTo(item.page)}
                                        selected={activePage === item.page}
                                    >
                                        <ListItemIcon>{item.icon}</ListItemIcon>
                                        <ListItemText primary={item.text} />
                                    </ListItem>
                                ))}
                            </List>
                            <Divider />
                            <Box sx={{ p: 2 }}>
                                <Button
                                    variant="outlined"
                                    color="error"
                                    fullWidth
                                    onClick={handleLogout}
                                >
                                    Logout
                                </Button>
                            </Box>
                        </Box>
                    </Drawer>
                </>
            )}

            <Container
                maxWidth={false}
                sx={{
                    mt: 4,
                    mb: 8,
                    display: 'flex',
                    flexDirection: 'column',
                    width: '100%',
                    px: { xs: 2, sm: 3 }
                }}
            >
                {!isLoggedIn && (
                    <Typography
                        variant="h2"
                        component="h1"
                        align="center"
                        gutterBottom
                        sx={{
                            fontWeight: 'bold',
                            backgroundImage: 'linear-gradient(45deg, #3f51b5, #f50057)',
                            backgroundClip: 'text',
                            color: 'transparent',
                            WebkitBackgroundClip: 'text',
                            WebkitTextFillColor: 'transparent',
                            mb: 4
                        }}
                    >
                        Evently
                    </Typography>
                )}

                {isLoggedIn ? (
                    renderAppContent()
                ) : (
                    <LandingPage onLoginSuccess={handleLoginSuccess} />
                )}
            </Container>
        </ThemeProvider>
    );
}

export default App;

================
File: frontend/src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: frontend/src/components/CreateEventForm.jsx
================
import React, { useState, useEffect } from 'react';
import {
    Dialog, DialogTitle, DialogContent, DialogActions,
    Button, TextField, FormControl, InputLabel, Select,
    MenuItem, Grid, Alert, CircularProgress,
    Box, Typography, InputAdornment
} from '@mui/material';
import { DateTimePicker } from '@mui/x-date-pickers/DateTimePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import {
    Event, LocationOn, Description, Category,
    Close, Save
} from '@mui/icons-material';
import { fetchApi } from '../utils/api';

const CreateEventForm = ({ open, onClose, onEventCreated }) => {
    const [formData, setFormData] = useState({
        name: '',
        description: '',
        location: '',
        event_date: new Date(),
        category_id: ''
    });
    
    const [loading, setLoading] = useState(false);
    const [categories, setCategories] = useState([]);
    const [loadingCategories, setLoadingCategories] = useState(false);
    const [error, setError] = useState(null);
    const [success, setSuccess] = useState(null);
    
    // Fetch categories when the component mounts
    useEffect(() => {
        const fetchCategories = async () => {
            setLoadingCategories(true);
            try {
                const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
                const response = await fetch(`${apiUrl}/api/categories`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch categories: ${response.status}`);
                }
                
                const data = await response.json();
                setCategories(data);
            } catch (error) {
                console.error('Error fetching categories:', error);
                setError('Failed to load categories. Please try again.');
            } finally {
                setLoadingCategories(false);
            }
        };
        
        if (open) {
            fetchCategories();
        }
    }, [open]);
    
    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setFormData({
            ...formData,
            [name]: value
        });
    };
    
    const handleDateChange = (newDate) => {
        setFormData({
            ...formData,
            event_date: newDate
        });
    };
    
    const validateForm = () => {
        if (!formData.name.trim()) {
            setError('Event name is required');
            return false;
        }
        
        if (!formData.category_id) {
            setError('Please select a category');
            return false;
        }
        
        return true;
    };
    
    const handleSubmit = async (e) => {
        e.preventDefault();
        
        if (!validateForm()) {
            return;
        }
        
        setLoading(true);
        setError(null);
        setSuccess(null);
        
        try {
            // Get the user ID from the JWT token
            const token = localStorage.getItem('authToken');
            if (!token) {
                throw new Error('You must be logged in to create an event');
            }
            
            // Decode the token to get the user ID
            const payload = token.split('.')[1];
            const decodedPayload = JSON.parse(atob(payload));
            const user_id = decodedPayload.userId;
            
            if (!user_id) {
                throw new Error('Unable to retrieve user ID from session');
            }
            
            // The user_id is now extracted from the JWT token on the server side
            // No need to explicitly send it in the request
            const eventData = {
                ...formData
            };
            
            // Format the date properly for the API
            if (eventData.event_date instanceof Date) {
                eventData.event_date = eventData.event_date.toISOString();
            }
            
            // Use the API URL from environment
            const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
            
            // Make the API request with authentication token
            const response = await fetch(`${apiUrl}/api/events`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify(eventData)
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Failed to create event: ${response.status}`);
            }
            
            const data = await response.json();
            setSuccess('Event created successfully!');
            
            // Reset form
            setFormData({
                name: '',
                description: '',
                location: '',
                event_date: new Date(),
                category_id: ''
            });
            
            // Notify parent component
            if (onEventCreated) {
                onEventCreated(data);
            }
            
            // Close the dialog after a short delay
            setTimeout(() => {
                onClose();
            }, 1500);
            
        } catch (error) {
            console.error('Error creating event:', error);
            setError(error.message || 'Failed to create event. Please try again.');
        } finally {
            setLoading(false);
        }
    };
    
    const handleClose = () => {
        // Reset form when closing
        setFormData({
            name: '',
            description: '',
            location: '',
            event_date: new Date(),
            category_id: ''
        });
        setError(null);
        setSuccess(null);
        onClose();
    };
    
    return (
        <Dialog 
            open={open} 
            onClose={handleClose}
            fullWidth
            maxWidth="md"
        >
            <DialogTitle>
                <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                    <Typography variant="h6">Create New Event</Typography>
                    <Button 
                        color="inherit" 
                        onClick={handleClose}
                        startIcon={<Close />}
                    >
                        Cancel
                    </Button>
                </Box>
            </DialogTitle>
            
            <form onSubmit={handleSubmit}>
                <DialogContent dividers>
                    {error && (
                        <Alert severity="error" sx={{ mb: 2 }}>
                            {error}
                        </Alert>
                    )}
                    
                    {success && (
                        <Alert severity="success" sx={{ mb: 2 }}>
                            {success}
                        </Alert>
                    )}
                    
                    <Grid container spacing={3}>
                        <Grid item xs={12}>
                            <TextField
                                label="Event Name"
                                name="name"
                                value={formData.name}
                                onChange={handleInputChange}
                                fullWidth
                                required
                                InputProps={{
                                    startAdornment: (
                                        <InputAdornment position="start">
                                            <Event />
                                        </InputAdornment>
                                    ),
                                }}
                            />
                        </Grid>
                        
                        <Grid item xs={12} sm={6}>
                            <LocalizationProvider dateAdapter={AdapterDateFns}>
                                <DateTimePicker 
                                    label="Event Date & Time"
                                    value={formData.event_date}
                                    onChange={handleDateChange}
                                    slotProps={{ textField: { fullWidth: true, required: true } }}
                                    disablePast
                                />
                            </LocalizationProvider>
                        </Grid>
                        
                        <Grid item xs={12} sm={6}>
                            <FormControl fullWidth required>
                                <InputLabel id="category-label">Category</InputLabel>
                                <Select
                                    labelId="category-label"
                                    name="category_id"
                                    value={formData.category_id}
                                    onChange={handleInputChange}
                                    startAdornment={
                                        <InputAdornment position="start">
                                            <Category />
                                        </InputAdornment>
                                    }
                                    disabled={loadingCategories}
                                >
                                    {loadingCategories ? (
                                        <MenuItem value="">
                                            <CircularProgress size={20} /> Loading...
                                        </MenuItem>
                                    ) : (
                                        categories.map((category) => (
                                            <MenuItem key={category.category_id} value={category.category_id}>
                                                {category.category_name}
                                            </MenuItem>
                                        ))
                                    )}
                                </Select>
                            </FormControl>
                        </Grid>
                        
                        <Grid item xs={12}>
                            <TextField
                                label="Location"
                                name="location"
                                value={formData.location}
                                onChange={handleInputChange}
                                fullWidth
                                InputProps={{
                                    startAdornment: (
                                        <InputAdornment position="start">
                                            <LocationOn />
                                        </InputAdornment>
                                    ),
                                }}
                            />
                        </Grid>
                        
                        <Grid item xs={12}>
                            <TextField
                                label="Description"
                                name="description"
                                value={formData.description}
                                onChange={handleInputChange}
                                fullWidth
                                multiline
                                rows={4}
                                InputProps={{
                                    startAdornment: (
                                        <InputAdornment position="start" sx={{ alignSelf: 'flex-start', mt: 1.5 }}>
                                            <Description />
                                        </InputAdornment>
                                    ),
                                }}
                            />
                        </Grid>
                    </Grid>
                </DialogContent>
                
                <DialogActions sx={{ p: 2 }}>
                    <Button
                        variant="contained"
                        color="primary"
                        type="submit"
                        disabled={loading}
                        startIcon={loading ? <CircularProgress size={20} /> : <Save />}
                    >
                        {loading ? 'Creating...' : 'Create Event'}
                    </Button>
                </DialogActions>
            </form>
        </Dialog>
    );
};

export default CreateEventForm;

================
File: frontend/src/components/Dashboard.jsx
================
import React, { useState, useEffect } from 'react';
import {
    Box, Typography, Grid, Card, CardContent,
    Divider, CircularProgress, Paper,
    List, ListItem, ListItemText, ListItemIcon, ListItemSecondaryAction,
    Chip, Tabs, Tab, Dialog, DialogTitle, DialogContent, Rating, Avatar,
    Button, Alert
} from '@mui/material';
import {
    EventAvailable, People, CalendarToday, Check,
    Event, History, Comment
} from '@mui/icons-material';
import StarRating from './StarRating';
import ReviewDialog from './ReviewDialog';

function Dashboard({ username }) {
    const [stats, setStats] = useState({
        totalEvents: 0,
        upcomingEvents: 0,
        totalAttendees: 0,
        completedEvents: 0
    });
    const [loading, setLoading] = useState(true);
    const [upcomingEvents, setUpcomingEvents] = useState([]);
    const [pastEvents, setPastEvents] = useState([]);
    const [eventTab, setEventTab] = useState(0);
    const [openReviewsDialog, setOpenReviewsDialog] = useState(false);
    const [selectedEvent, setSelectedEvent] = useState(null);
    const [eventReviews, setEventReviews] = useState([]);
    const [loadingReviews, setLoadingReviews] = useState(false);
    const [error, setError] = useState(null);

    // Get JWT token from localStorage
    const getToken = () => {
        const token = localStorage.getItem('authToken');
        console.log('Token found in Dashboard:', token ? 'Yes' : 'No');
        return token;
    };

    useEffect(() => {
        const fetchDashboardData = async () => {
            setLoading(true);
            setError(null);
            try {
                const token = getToken();
                if (!token) {
                    console.error('No authentication token found');
                    setLoading(false);
                    return;
                }
    
                const headers = {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                };
    
                console.log('Dashboard: Fetching all events');
    
                const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
                // Fetch all events from a single endpoint
                const eventsResponse = await fetch(`${apiUrl}/api/events`, { headers });
                if (!eventsResponse.ok) {
                    console.error('Events fetch error:', eventsResponse.status);
                    throw new Error('Failed to fetch events');
                }
                const eventsData = await eventsResponse.json();
                console.log('Events data received:', eventsData.length, 'events');
    
                // Try to fetch stats, but use calculated values if it fails
                let statsData = {};
                try {
                    const statsResponse = await fetch(`${apiUrl}/api/dashboard/stats`, { headers });
                    if (statsResponse.ok) {
                        statsData = await statsResponse.json();
                        console.log('Stats data received:', statsData);
                    } else {
                        console.error('Stats fetch error:', statsResponse.status);
                        throw new Error('Failed to fetch stats');
                    }
                } catch (statsError) {
                    console.log('Using calculated stats due to API error');
                    // Calculate stats based on events data
                    const today = new Date();
                    today.setHours(0, 0, 0, 0); // Set to midnight
                    
                    const upcoming = eventsData.filter(event => {
                        const eventDate = new Date(event.event_date);
                        const normalizedDate = new Date(
                            eventDate.getFullYear(),
                            eventDate.getMonth(),
                            eventDate.getDate(),
                            0, 0, 0, 0
                        );
                        return normalizedDate >= today;
                    }).length;
                    
                    const completed = eventsData.length - upcoming;
                    
                    // Sum all attendees or use default value
                    const totalAttendees = eventsData.reduce((sum, event) => sum + (event.attendees || 0), 0);
                    
                    statsData = {
                        totalEvents: eventsData.length,
                        upcomingEvents: upcoming,
                        completedEvents: completed,
                        totalAttendees: totalAttendees
                    };
                }
                
                setStats(statsData);

                // Categorize events by date with improved comparison
                const today = new Date();
                today.setHours(0, 0, 0, 0); // Set to midnight

                const upcoming = [];
                const past = [];

                eventsData.forEach(event => {
                    try {
                        const eventDate = new Date(event.event_date);
                        const normalizedDate = new Date(
                            eventDate.getFullYear(),
                            eventDate.getMonth(),
                            eventDate.getDate(),
                            0, 0, 0, 0
                        );
                        
                        if (normalizedDate >= today) {
                            upcoming.push(event);
                        } else {
                            // Add mock review data for display purposes
                            const mockReviewCount = event.review_count !== undefined ? 
                                event.review_count : Math.floor(Math.random() * 3);
                            const mockAvgRating = event.avg_rating !== undefined ?
                                event.avg_rating : (3 + Math.random() * 2).toFixed(1);
                                
                            past.push({
                                ...event,
                                review_count: mockReviewCount,
                                avg_rating: mockAvgRating
                            });
                        }
                    } catch (dateError) {
                        console.error('Error parsing date for event:', event.name, dateError);
                    }
                });

                // Sort upcoming events by date (earliest first)
                upcoming.sort((a, b) => new Date(a.event_date) - new Date(b.event_date));
                
                // Sort past events by date (latest first)
                past.sort((a, b) => new Date(b.event_date) - new Date(a.event_date));

                setUpcomingEvents(upcoming);
                setPastEvents(past);

            } catch (error) {
                console.error('Error fetching dashboard data:', error);
                setError(error.message);
                
                // Set empty arrays to prevent errors
                setUpcomingEvents([]);
                setPastEvents([]);
            } finally {
                setLoading(false);
            }
        };
    
        fetchDashboardData();
    }, []);

    // Fetch reviews for a specific event
    const fetchEventReviews = async (eventId) => {
        setLoadingReviews(true);
        try {
            const token = getToken();
            if (!token) {
                console.error('No authentication token found');
                setLoadingReviews(false);
                return;
            }

            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };

            try {
                // Try the API endpoint first
                const response = await fetch(`http://localhost:5000/api/events/${eventId}/reviews`, { headers });
                if (response.ok) {
                    const data = await response.json();
                    setEventReviews(data);
                    return;
                }
                console.error('Reviews fetch error:', response.status);
                throw new Error('Failed to fetch reviews');
            } catch (apiError) {
                // Fallback to mock data if API fails
                console.log('Using mock reviews data');
                const mockReviews = [
                    {
                        review_id: 1,
                        username: 'MockUser1',
                        rating: 4,
                        review_text: 'This was a great event! Really enjoyed the presentations.',
                        created_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
                    },
                    {
                        review_id: 2,
                        username: 'MockUser2',
                        rating: 5,
                        review_text: 'Excellent organization and content. Looking forward to the next one!',
                        created_at: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()
                    }
                ];
                setEventReviews(mockReviews);
            }
        } catch (error) {
            console.error('Error fetching event reviews:', error);
            setEventReviews([]); // Set empty array as fallback
        } finally {
            setLoadingReviews(false);
        }
    };

    // Replace the existing reviews dialog opening function with this enhanced version
    const handleOpenReviews = (event) => {
        setSelectedEvent(event);
        setOpenReviewsDialog(true);
    };

    const handleCloseReviews = () => {
        setOpenReviewsDialog(false);
        setSelectedEvent(null);
        setEventReviews([]);
    };

    const formatDate = (dateString) => {
        const date = new Date(dateString);
        return new Intl.DateTimeFormat('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric'
        }).format(date);
    };

    const getDaysRemaining = (dateString) => {
        const eventDate = new Date(dateString);
        const today = new Date();
        const diffTime = eventDate - today;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays;
    };

    const formatRating = (rating) => {
        return rating ? parseFloat(rating).toFixed(1) : 'No ratings';
    };

    const handleTabChange = (event, newValue) => {
        setEventTab(newValue);
    };

    return (
        <Box sx={{ width: '100%' }}>
            <Box sx={{ mb: 4 }}>
                <Typography variant="h4" component="h1" gutterBottom sx={{ fontWeight: 'bold' }}>
                    Welcome back, {username || 'User'}!
                </Typography>
                <Typography variant="body1" color="text.secondary">
                    Here's an overview of your events and activities
                </Typography>
            </Box>

            {error && (
                <Alert severity="warning" sx={{ mb: 3 }}>
                    Note: Some data may be estimated due to API error: {error}
                </Alert>
            )}

            {/* Stats Cards */}
            <Grid container spacing={3} sx={{ mb: 4 }}>
                <Grid item xs={12} sm={6} lg={3}>
                    <Card sx={{ height: '100%', borderRadius: 2 }}>
                        <CardContent>
                            {loading ? (
                                <Box sx={{ display: 'flex', justifyContent: 'center', py: 2 }}>
                                    <CircularProgress size={30} />
                                </Box>
                            ) : (
                                <>
                                    <Box sx={{
                                        display: 'flex',
                                        alignItems: 'center',
                                        mb: 2
                                    }}>
                                        <Box sx={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            width: 40,
                                            height: 40,
                                            borderRadius: '50%',
                                            bgcolor: 'primary.light',
                                            color: 'primary.main',
                                            mr: 2
                                        }}>
                                            <EventAvailable sx={{ fontSize: 20 }} />
                                        </Box>
                                        <Typography color="text.secondary" variant="body2">
                                            Total Events
                                        </Typography>
                                    </Box>
                                    <Typography variant="h4" component="div" sx={{ fontWeight: 'bold' }}>
                                        {stats.totalEvents || (upcomingEvents.length + pastEvents.length)}
                                    </Typography>
                                </>
                            )}
                        </CardContent>
                    </Card>
                </Grid>

                <Grid item xs={12} sm={6} lg={3}>
                    <Card sx={{ height: '100%', borderRadius: 2 }}>
                        <CardContent>
                            {loading ? (
                                <Box sx={{ display: 'flex', justifyContent: 'center', py: 2 }}>
                                    <CircularProgress size={30} />
                                </Box>
                            ) : (
                                <>
                                    <Box sx={{
                                        display: 'flex',
                                        alignItems: 'center',
                                        mb: 2
                                    }}>
                                        <Box sx={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            width: 40,
                                            height: 40,
                                            borderRadius: '50%',
                                            bgcolor: 'secondary.light',
                                            color: 'secondary.main',
                                            mr: 2
                                        }}>
                                            <CalendarToday sx={{ fontSize: 20 }} />
                                        </Box>
                                        <Typography color="text.secondary" variant="body2">
                                            Upcoming Events
                                        </Typography>
                                    </Box>
                                    <Typography variant="h4" component="div" sx={{ fontWeight: 'bold' }}>
                                        {stats.upcomingEvents || upcomingEvents.length}
                                    </Typography>
                                </>
                            )}
                        </CardContent>
                    </Card>
                </Grid>

                <Grid item xs={12} sm={6} lg={3}>
                    <Card sx={{ height: '100%', borderRadius: 2 }}>
                        <CardContent>
                            {loading ? (
                                <Box sx={{ display: 'flex', justifyContent: 'center', py: 2 }}>
                                    <CircularProgress size={30} />
                                </Box>
                            ) : (
                                <>
                                    <Box sx={{
                                        display: 'flex',
                                        alignItems: 'center',
                                        mb: 2
                                    }}>
                                        <Box sx={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            width: 40,
                                            height: 40,
                                            borderRadius: '50%',
                                            bgcolor: 'info.light',
                                            color: 'info.main',
                                            mr: 2
                                        }}>
                                            <People sx={{ fontSize: 20 }} />
                                        </Box>
                                        <Typography color="text.secondary" variant="body2">
                                            Total Attendees
                                        </Typography>
                                    </Box>
                                    <Typography variant="h4" component="div" sx={{ fontWeight: 'bold' }}>
                                        {stats.totalAttendees || 0}
                                    </Typography>
                                </>
                            )}
                        </CardContent>
                    </Card>
                </Grid>

                <Grid item xs={12} sm={6} lg={3}>
                    <Card sx={{ height: '100%', borderRadius: 2 }}>
                        <CardContent>
                            {loading ? (
                                <Box sx={{ display: 'flex', justifyContent: 'center', py: 2 }}>
                                    <CircularProgress size={30} />
                                </Box>
                            ) : (
                                <>
                                    <Box sx={{
                                        display: 'flex',
                                        alignItems: 'center',
                                        mb: 2
                                    }}>
                                        <Box sx={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            width: 40,
                                            height: 40,
                                            borderRadius: '50%',
                                            bgcolor: 'success.light',
                                            color: 'success.main',
                                            mr: 2
                                        }}>
                                            <Check sx={{ fontSize: 20 }} />
                                        </Box>
                                        <Typography color="text.secondary" variant="body2">
                                            Completed Events
                                        </Typography>
                                    </Box>
                                    <Typography variant="h4" component="div" sx={{ fontWeight: 'bold' }}>
                                        {stats.completedEvents || pastEvents.length}
                                    </Typography>
                                </>
                            )}
                        </CardContent>
                    </Card>
                </Grid>
            </Grid>

            {/* Events Tabs */}
            <Box sx={{ mb: 2 }}>
                <Tabs
                    value={eventTab}
                    onChange={handleTabChange}
                    aria-label="event tabs"
                    sx={{ borderBottom: 1, borderColor: 'divider' }}
                >
                    <Tab
                        label="Upcoming Events"
                        icon={<CalendarToday fontSize="small" />}
                        iconPosition="start"
                    />
                    <Tab
                        label="Past Events"
                        icon={<History fontSize="small" />}
                        iconPosition="start"
                    />
                </Tabs>
            </Box>

            {/* Events Content */}
            <Box sx={{ mb: 4 }}>
                {/* Upcoming Events Tab Panel */}
                {eventTab === 0 && (
                    <Paper sx={{ borderRadius: 2, overflow: 'hidden' }}>
                        {loading ? (
                            <Box sx={{ p: 3 }}>
                                <CircularProgress size={30} sx={{ display: 'block', mx: 'auto' }} />
                            </Box>
                        ) : upcomingEvents.length > 0 ? (
                            <List disablePadding>
                                {upcomingEvents.map((event, index) => {
                                    const daysRemaining = getDaysRemaining(event.event_date);
                                    return (
                                        <React.Fragment key={event.event_id}>
                                            <ListItem sx={{ px: 3, py: 2 }}>
                                                <ListItemIcon>
                                                    <Event color="primary" />
                                                </ListItemIcon>
                                                <ListItemText
                                                    primary={
                                                        <Typography variant="subtitle1" component="div" sx={{ fontWeight: 'medium' }}>
                                                            {event.name}
                                                        </Typography>
                                                    }
                                                    secondary={
                                                        <>
                                                            <Typography variant="body2" component="span" display="block">
                                                                {formatDate(event.event_date)} â€¢ {event.location || 'No location'}
                                                            </Typography>
                                                            <Typography variant="body2" component="span" display="block">
                                                                {event.attendees || 0} attendees
                                                            </Typography>
                                                        </>
                                                    }
                                                />
                                                <ListItemSecondaryAction>
                                                    <Chip
                                                        label={daysRemaining > 0 ? `${daysRemaining} days left` : 'Today!'}
                                                        color={daysRemaining <= 1 ? "error" : daysRemaining <= 3 ? "warning" : "primary"}
                                                        size="small"
                                                    />
                                                </ListItemSecondaryAction>
                                            </ListItem>
                                            {index < upcomingEvents.length - 1 && <Divider component="li" />}
                                        </React.Fragment>
                                    );
                                })}
                            </List>
                        ) : (
                            <Box sx={{ p: 3, textAlign: 'center' }}>
                                <Typography variant="body1" color="text.secondary">
                                    No upcoming events scheduled
                                </Typography>
                            </Box>
                        )}
                    </Paper>
                )}

                {/* Past Events Tab Panel */}
                {eventTab === 1 && (
                    <Paper sx={{ borderRadius: 2, overflow: 'hidden' }}>
                        {loading ? (
                            <Box sx={{ p: 3 }}>
                                <CircularProgress size={30} sx={{ display: 'block', mx: 'auto' }} />
                            </Box>
                        ) : pastEvents.length > 0 ? (
                            <List disablePadding>
                                {pastEvents.map((event, index) => (
                                    <React.Fragment key={event.event_id}>
                                        <ListItem
                                            sx={{ px: 3, py: 2, cursor: 'pointer' }}
                                            onClick={() => handleOpenReviews(event)}
                                        >
                                            <ListItemIcon>
                                                <Event color="action" />
                                            </ListItemIcon>
                                            <ListItemText
                                                primary={
                                                    <Typography variant="subtitle1" component="div" sx={{ fontWeight: 'medium' }}>
                                                        {event.name}
                                                    </Typography>
                                                }
                                                secondary={
                                                    <>
                                                        <Typography variant="body2" component="span" display="block">
                                                            {formatDate(event.event_date)} â€¢ {event.location || 'No location'}
                                                        </Typography>
                                                        <Typography variant="body2" component="span" display="block">
                                                            {event.attendees || 0} attendees
                                                        </Typography>
                                                        {event.review_count > 0 && (
                                                            <Box sx={{ display: 'flex', alignItems: 'center', mt: 0.5 }}>
                                                                <StarRating 
                                                                    value={parseFloat(event.avg_rating) || 0} 
                                                                    readOnly 
                                                                    size="small" 
                                                                />
                                                                <Typography variant="body2" color="text.secondary" sx={{ ml: 1 }}>
                                                                    {formatRating(event.avg_rating)} ({event.review_count} reviews)
                                                                </Typography>
                                                            </Box>
                                                        )}
                                                    </>
                                                }
                                            />
                                            <ListItemSecondaryAction>
                                                <Chip
                                                    icon={<Comment fontSize="small" />}
                                                    label={event.review_count > 0 ? `${event.review_count} Reviews` : "No Reviews"}
                                                    color={event.review_count > 0 ? "primary" : "default"}
                                                    size="small"
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        handleOpenReviews(event);
                                                    }}
                                                />
                                            </ListItemSecondaryAction>
                                        </ListItem>
                                        {index < pastEvents.length - 1 && <Divider component="li" />}
                                    </React.Fragment>
                                ))}
                            </List>
                        ) : (
                            <Box sx={{ p: 3, textAlign: 'center' }}>
                                <Typography variant="body1" color="text.secondary">
                                    No past events found
                                </Typography>
                            </Box>
                        )}
                    </Paper>
                )}
            </Box>

            {/* Enhanced Reviews Dialog */}
            <ReviewDialog
                open={openReviewsDialog}
                onClose={() => {
                    setOpenReviewsDialog(false);
                    setSelectedEvent(null);
                    // Refresh dashboard data to show updated review counts/ratings
                    fetchDashboardData();
                }}
                eventId={selectedEvent?.event_id}
                eventName={selectedEvent?.name}
                eventDate={selectedEvent?.event_date}
                eventLocation={selectedEvent?.location}
                initialRating={selectedEvent?.avg_rating}
                reviewCount={selectedEvent?.review_count}
            />
        </Box>
    );
}

export default Dashboard;

================
File: frontend/src/components/EventDetail.jsx
================
// EventDetail.jsx - Enhanced event detail page with review functionality
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
    Box, Typography, Paper, Button, Divider, Card, CardContent,
    Grid, Chip, Avatar, Alert, CircularProgress, Stack,
    ListItem, ListItemText, ListItemAvatar, List
} from '@mui/material';
import {
    LocationOn, CalendarToday, Person, ArrowBack,
    Category, EventAvailable, Comment, Share, Add
} from '@mui/icons-material';
import StarRating from './StarRating';
import ReviewDialog from './ReviewDialog';

const EventDetail = () => {
    const { eventId } = useParams();
    const navigate = useNavigate();
    
    const [event, setEvent] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [reviews, setReviews] = useState([]);
    const [loadingReviews, setLoadingReviews] = useState(false);
    const [openReviewDialog, setOpenReviewDialog] = useState(false);
    const [similarEvents, setSimilarEvents] = useState([]);
    
    // Get JWT token from localStorage
    const getToken = () => {
        return localStorage.getItem('authToken');
    };
    
    // Format date for display
    const formatDate = (dateString) => {
        const date = new Date(dateString);
        return new Intl.DateTimeFormat('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric'
        }).format(date);
    };
    
    // Check if event date is in the past
    const isEventPast = (dateString) => {
        const eventDate = new Date(dateString);
        return eventDate < new Date();
    };
    
    // Fetch event data
    useEffect(() => {
        const fetchEventData = async () => {
            setLoading(true);
            setError(null);
            
            try {
                const token = getToken();
                const headers = token ? {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                } : {
                    'Content-Type': 'application/json'
                };
                
                // Fetch event details
                const eventResponse = await fetch(`http://localhost:5000/api/events/${eventId}`, { headers });
                if (!eventResponse.ok) {
                    throw new Error(`Failed to fetch event: ${eventResponse.status}`);
                }
                
                const eventData = await eventResponse.json();
                setEvent(eventData);
                
                // Fetch event reviews
                setLoadingReviews(true);
                try {
                    const reviewsResponse = await fetch(`http://localhost:5000/api/events/${eventId}/reviews`, { headers });
                    if (reviewsResponse.ok) {
                        const reviewsData = await reviewsResponse.json();
                        setReviews(reviewsData);
                    }
                } catch (error) {
                    console.error('Error fetching reviews:', error);
                } finally {
                    setLoadingReviews(false);
                }
                
                // Fetch similar events (same category)
                try {
                    if (eventData.category_id) {
                        const similarEventsResponse = await fetch(
                            `http://localhost:5000/api/events?category_id=${eventData.category_id}&limit=3`, 
                            { headers }
                        );
                        
                        if (similarEventsResponse.ok) {
                            const similarEventsData = await similarEventsResponse.json();
                            // Filter out the current event
                            setSimilarEvents(
                                similarEventsData.filter(e => e.event_id !== parseInt(eventId))
                            );
                        }
                    }
                } catch (error) {
                    console.error('Error fetching similar events:', error);
                }
            } catch (error) {
                console.error('Error fetching event data:', error);
                setError(error.message);
            } finally {
                setLoading(false);
            }
        };
        
        if (eventId) {
            fetchEventData();
        }
    }, [eventId]);
    
    // Calculate average rating
    const getAverageRating = () => {
        if (!reviews || reviews.length === 0) return 0;
        
        const totalRating = reviews.reduce((sum, review) => sum + review.rating, 0);
        return totalRating / reviews.length;
    };
    
    // Add to calendar
    const addToCalendar = () => {
        if (!event) return;
        
        const { name, description, location, event_date } = event;
        const eventStart = new Date(event_date);
        // Default duration 2 hours
        const eventEnd = new Date(eventStart.getTime() + 2 * 60 * 60 * 1000);
        
        // Format dates for Google Calendar
        const formatGoogleDate = (date) => {
            return date.toISOString().replace(/-|:|\.\d\d\d/g, '');
        };
        
        // Create Google Calendar URL
        const googleCalendarUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(name)}&dates=${formatGoogleDate(eventStart)}/${formatGoogleDate(eventEnd)}&details=${encodeURIComponent(description || '')}&location=${encodeURIComponent(location || '')}&sf=true&output=xml`;
        
        // Open in new window
        window.open(googleCalendarUrl, '_blank');
    };
    
    // Share event
    const shareEvent = () => {
        if (navigator.share) {
            navigator.share({
                title: event?.name || 'Event',
                text: `Check out this event: ${event?.name}`,
                url: window.location.href
            });
        } else {
            // Fallback for browsers that don't support the Web Share API
            navigator.clipboard.writeText(window.location.href);
            alert('Link copied to clipboard!');
        }
    };
    
    // Loading state
    if (loading) {
        return (
            <Box sx={{ display: 'flex', justifyContent: 'center', py: 8 }}>
                <CircularProgress />
            </Box>
        );
    }
    
    // Error state
    if (error) {
        return (
            <Box sx={{ maxWidth: 'md', mx: 'auto', mt: 4 }}>
                <Alert severity="error">{error}</Alert>
                <Button 
                    variant="contained" 
                    sx={{ mt: 2 }} 
                    onClick={() => navigate(-1)}
                    startIcon={<ArrowBack />}
                >
                    Go Back
                </Button>
            </Box>
        );
    }
    
    // If event not found
    if (!event) {
        return (
            <Box sx={{ maxWidth: 'md', mx: 'auto', mt: 4 }}>
                <Alert severity="warning">Event not found</Alert>
                <Button 
                    variant="contained" 
                    sx={{ mt: 2 }} 
                    onClick={() => navigate('/events')}
                    startIcon={<ArrowBack />}
                >
                    Back to Events
                </Button>
            </Box>
        );
    }
    
    const avgRating = getAverageRating();
    const isPast = isEventPast(event.event_date);
    
    return (
        <Box sx={{ maxWidth: 'lg', mx: 'auto' }}>
            {/* Back button */}
            <Button 
                variant="text" 
                startIcon={<ArrowBack />} 
                onClick={() => navigate(-1)}
                sx={{ mb: 2 }}
            >
                Back
            </Button>
            
            {/* Main content */}
            <Grid container spacing={3}>
                {/* Event details */}
                <Grid item xs={12} md={8}>
                    <Card sx={{ mb: 3 }}>
                        <Box 
                            sx={{ 
                                height: 200, 
                                bgcolor: 'primary.main', 
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                color: 'white',
                                position: 'relative'
                            }}
                        >
                            <Typography variant="h4" component="div" sx={{ fontWeight: 'bold', zIndex: 1 }}>
                                {event.name}
                            </Typography>
                            
                            {/* Status badge */}
                            <Chip
                                label={isPast ? 'Past Event' : 'Upcoming'}
                                color={isPast ? 'default' : 'success'}
                                sx={{ 
                                    position: 'absolute', 
                                    top: 16, 
                                    right: 16
                                }}
                            />
                        </Box>
                        
                        <CardContent>
                            {/* Event details */}
                            <Grid container spacing={2}>
                                <Grid item xs={12} sm={6}>
                                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                                        <CalendarToday color="primary" sx={{ mr: 1 }} />
                                        <Typography variant="body1">
                                            {formatDate(event.event_date)}
                                        </Typography>
                                    </Box>
                                </Grid>
                                
                                <Grid item xs={12} sm={6}>
                                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                                        <LocationOn color="primary" sx={{ mr: 1 }} />
                                        <Typography variant="body1">
                                            {event.location || 'No location specified'}
                                        </Typography>
                                    </Box>
                                </Grid>
                                
                                {event.category_name && (
                                    <Grid item xs={12} sm={6}>
                                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                                            <Category color="primary" sx={{ mr: 1 }} />
                                            <Typography variant="body1">
                                                Category: {event.category_name}
                                            </Typography>
                                        </Box>
                                    </Grid>
                                )}
                                
                                {event.attendees > 0 && (
                                    <Grid item xs={12} sm={6}>
                                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                                            <Person color="primary" sx={{ mr: 1 }} />
                                            <Typography variant="body1">
                                                {event.attendees} Attendees
                                            </Typography>
                                        </Box>
                                    </Grid>
                                )}
                            </Grid>
                            
                            <Divider sx={{ my: 2 }} />
                            
                            {/* Event description */}
                            <Typography variant="h6" gutterBottom>
                                About this event
                            </Typography>
                            <Typography variant="body1" paragraph>
                                {event.description || 'No description provided for this event.'}
                            </Typography>
                            
                            {/* Event rating summary */}
                            <Box sx={{ mt: 3 }}>
                                <Typography variant="h6" gutterBottom>
                                    Event Rating
                                </Typography>
                                <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                                    <StarRating 
                                        value={avgRating} 
                                        readOnly 
                                        size="large"
                                        showValue
                                    />
                                    <Typography variant="body2" color="text.secondary" sx={{ ml: 1 }}>
                                        ({reviews.length} {reviews.length === 1 ? 'review' : 'reviews'})
                                    </Typography>
                                </Box>
                            </Box>
                            
                            {/* Action buttons */}
                            <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 3, gap: 2 }}>
                                <Button 
                                    variant="outlined"
                                    startIcon={<Share />}
                                    onClick={shareEvent}
                                >
                                    Share
                                </Button>
                                
                                <Button 
                                    variant="outlined"
                                    startIcon={<CalendarToday />}
                                    onClick={addToCalendar}
                                >
                                    Add to Calendar
                                </Button>
                                
                                <Button 
                                    variant="contained"
                                    startIcon={isPast ? <Comment /> : <EventAvailable />}
                                    onClick={() => {
                                        if (isPast) {
                                            setOpenReviewDialog(true);
                                        } else {
                                            // Logic to RSVP for event
                                            console.log('RSVP for event', event.event_id);
                                        }
                                    }}
                                >
                                    {isPast ? 'See Reviews' : 'RSVP'}
                                </Button>
                            </Box>
                        </CardContent>
                    </Card>
                    
                    {/* Recent reviews */}
                    <Card>
                        <CardContent>
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                                <Typography variant="h6">
                                    Recent Reviews
                                </Typography>
                                <Button 
                                    variant="text" 
                                    endIcon={<Add />}
                                    onClick={() => setOpenReviewDialog(true)}
                                >
                                    {reviews.length > 0 ? 'See All Reviews' : 'Add Review'}
                                </Button>
                            </Box>
                            
                            <Divider sx={{ mb: 2 }} />
                            
                            {loadingReviews ? (
                                <Box sx={{ display: 'flex', justifyContent: 'center', py: 3 }}>
                                    <CircularProgress size={30} />
                                </Box>
                            ) : reviews.length > 0 ? (
                                <List>
                                    {reviews.slice(0, 3).map((review) => (
                                        <ListItem key={review.review_id} alignItems="flex-start" sx={{ px: 0 }}>
                                            <ListItemAvatar>
                                                <Avatar>
                                                    {review.username?.charAt(0).toUpperCase() || 'U'}
                                                </Avatar>
                                            </ListItemAvatar>
                                            <ListItemText
                                                primary={
                                                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                                        <Typography variant="subtitle1" component="span">
                                                            {review.username}
                                                        </Typography>
                                                        <Box sx={{ ml: 'auto' }}>
                                                            <StarRating value={review.rating} readOnly size="small" />
                                                        </Box>
                                                    </Box>
                                                }
                                                secondary={
                                                    <>
                                                        <Typography variant="body2" color="text.primary" sx={{ mb: 0.5 }}>
                                                            {review.review_text || "No comment provided"}
                                                        </Typography>
                                                        <Typography variant="caption" color="text.secondary">
                                                            {new Date(review.created_at).toLocaleDateString()}
                                                        </Typography>
                                                    </>
                                                }
                                            />
                                        </ListItem>
                                    ))}
                                </List>
                            ) : (
                                <Box sx={{ py: 3, textAlign: 'center' }}>
                                    <Typography variant="body1" color="text.secondary">
                                        No reviews yet for this event.
                                    </Typography>
                                    <Button 
                                        variant="outlined" 
                                        startIcon={<Add />} 
                                        sx={{ mt: 2 }}
                                        onClick={() => setOpenReviewDialog(true)}
                                    >
                                        Be the first to review
                                    </Button>
                                </Box>
                            )}
                        </CardContent>
                    </Card>
                </Grid>
                
                {/* Sidebar */}
                <Grid item xs={12} md={4}>
                    {/* Event organizer */}
                    <Card sx={{ mb: 3 }}>
                        <CardContent>
                            <Typography variant="h6" gutterBottom>
                                Event Organizer
                            </Typography>
                            
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <Avatar sx={{ mr: 2 }}>
                                    {event.organizer_name ? event.organizer_name.charAt(0).toUpperCase() : 'O'}
                                </Avatar>
                                <Box>
                                    <Typography variant="subtitle1">
                                        {event.organizer_name || 'Event Organizer'}
                                    </Typography>
                                    <Typography variant="body2" color="text.secondary">
                                        {event.organizer_email || 'Contact information not available'}
                                    </Typography>
                                </Box>
                            </Box>
                        </CardContent>
                    </Card>
                    
                    {/* Similar events */}
                    <Card>
                        <CardContent>
                            <Typography variant="h6" gutterBottom>
                                Similar Events
                            </Typography>
                            
                            {similarEvents.length > 0 ? (
                                <Stack spacing={2}>
                                    {similarEvents.map((similarEvent) => (
                                        <Paper 
                                            key={similarEvent.event_id} 
                                            elevation={0} 
                                            sx={{ 
                                                p: 2, 
                                                bgcolor: 'background.default',
                                                cursor: 'pointer',
                                                '&:hover': {
                                                    bgcolor: 'action.hover'
                                                }
                                            }}
                                            onClick={() => navigate(`/events/${similarEvent.event_id}`)}
                                        >
                                            <Typography variant="subtitle1" sx={{ fontWeight: 'medium', mb: 0.5 }}>
                                                {similarEvent.name}
                                            </Typography>
                                            <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                                                <CalendarToday fontSize="small" sx={{ mr: 0.5, color: 'text.secondary' }} />
                                                <Typography variant="body2" color="text.secondary">
                                                    {new Date(similarEvent.event_date).toLocaleDateString()}
                                                </Typography>
                                            </Box>
                                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                                <LocationOn fontSize="small" sx={{ mr: 0.5, color: 'text.secondary' }} />
                                                <Typography variant="body2" color="text.secondary">
                                                    {similarEvent.location || 'No location'}
                                                </Typography>
                                            </Box>
                                        </Paper>
                                    ))}
                                </Stack>
                            ) : (
                                <Typography variant="body2" color="text.secondary" sx={{ py: 2 }}>
                                    No similar events found
                                </Typography>
                            )}
                        </CardContent>
                    </Card>
                </Grid>
            </Grid>
            
            {/* Review Dialog */}
            <ReviewDialog
                open={openReviewDialog}
                onClose={() => setOpenReviewDialog(false)}
                eventId={event.event_id}
                eventName={event.name}
                eventDate={event.event_date}
                eventLocation={event.location}
                initialRating={avgRating}
                reviewCount={reviews.length}
            />
        </Box>
    );
};

export default EventDetail;

================
File: frontend/src/components/EventsList.jsx
================
import React, { useState, useEffect } from 'react';
import {
    Container, Typography, Box, Grid, Card, CardContent,
    CardMedia, CardActions, Button, Chip, IconButton,
    Skeleton, Alert, Divider, CircularProgress, Avatar,
    Tabs, Tab, Paper, Rating
} from '@mui/material';
import {
    LocationOn, AccessTime, CalendarToday,
    Share, FavoriteBorder, Favorite, History, Star, Event
} from '@mui/icons-material';
import { Add } from '@mui/icons-material';
import CreateEventForm from './CreateEventForm';
import { Tooltip, Fab } from '@mui/material';

function EventsList() {
    const [events, setEvents] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [favorites, setFavorites] = useState({});
    const [activeTab, setActiveTab] = useState(0);
    const [createEventOpen, setCreateEventOpen] = useState(false);

    useEffect(() => {
        fetchEvents();
    }, []);

    const fetchEvents = async () => {
        setLoading(true);
        setError(null);
        try {
            console.log("Fetching events...");
            // Get authentication token
            const token = localStorage.getItem('authToken');

            const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
            // Since we're having issues with the dedicated endpoints, let's use the main events endpoint
            // which doesn't require authentication
            const response = await fetch(`${apiUrl}/api/events`);

            if (!response.ok) {
                throw new Error(`HTTP error fetching events: ${response.status}`);
            }

            const data = await response.json();
            console.log('All events:', data);

            // Now separate the events into upcoming and past based on date
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Set to midnight for consistent comparison

            const upcomingEvents = [];
            const pastEvents = [];

            data.forEach(event => {
                // Parse event date and set to midnight for comparison
                const eventDate = new Date(event.event_date);
                const normalizedEventDate = new Date(
                    eventDate.getFullYear(),
                    eventDate.getMonth(),
                    eventDate.getDate(),
                    0, 0, 0, 0
                );

                if (normalizedEventDate >= today) {
                    upcomingEvents.push(event);
                } else {
                    // Add mock review data for past events
                    // In a real app, you'd fetch this from an API
                    pastEvents.push({
                        ...event,
                        review_count: Math.floor(Math.random() * 5), // Random number of reviews
                        avg_rating: (3 + Math.random() * 2).toFixed(1) // Random rating between 3-5
                    });
                }
            });

            // Sort events by date
            upcomingEvents.sort((a, b) => new Date(a.event_date) - new Date(b.event_date));
            pastEvents.sort((a, b) => new Date(b.event_date) - new Date(a.event_date)); // Past events in reverse

            setEvents({ upcoming: upcomingEvents, past: pastEvents });

        } catch (e) {
            setError(e);
            console.error("Error fetching events:", e);

            // Set empty arrays to avoid undefined errors
            setEvents({ upcoming: [], past: [] });
        } finally {
            setLoading(false);
        }
    };

    const toggleFavorite = (eventId) => {
        setFavorites(prev => ({
            ...prev,
            [eventId]: !prev[eventId]
        }));
    };

    const formatDate = (dateString) => {
        const date = new Date(dateString);
        return new Intl.DateTimeFormat('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric',
            year: 'numeric'
        }).format(date);
    };

    const handleTabChange = (event, newValue) => {
        setActiveTab(newValue);
    };

    const formatRating = (rating) => {
        return rating ? parseFloat(rating).toFixed(1) : 'No ratings';
    };

    const handleOpenCreateEvent = () => {
        setCreateEventOpen(true);
    };

    const handleCloseCreateEvent = () => {
        setCreateEventOpen(false);
    };

    const handleEventCreated = (newEvent) => {
        // Add the new event to the state and refetch events
        setEvents(prev => {
            // Deep copy the previous state
            const updated = JSON.parse(JSON.stringify(prev));

            // Add to upcoming events if date is in the future
            const eventDate = new Date(newEvent.event_date);
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (eventDate >= today) {
                if (updated.upcoming) {
                    updated.upcoming = [newEvent, ...updated.upcoming];
                }
            } else {
                if (updated.past) {
                    updated.past = [newEvent, ...updated.past];
                }
            }

            return updated;
        });

        // Refetch events to get the updated list
        fetchEvents();
    };

    // Empty state with sample data
    const sampleEvents = loading ? [
        {
            event_id: 'sample1',
            name: 'Sample Event',
            event_date: new Date().toISOString(),
            location: 'Sample Location',
            description: 'This is a placeholder description for a sample event while your data loads.'
        },
        {
            event_id: 'sample2',
            name: 'Another Event',
            event_date: new Date().toISOString(),
            location: 'Virtual',
            description: 'Another placeholder description for demonstration purposes.'
        }
    ] : [];

    const renderUpcomingEvents = () => {
        const displayEvents = loading ? sampleEvents :
            (events && events.upcoming ? events.upcoming : []);

        if (displayEvents.length === 0 && !loading) {
            return (
                <Box sx={{ textAlign: 'center', py: 6 }}>
                    <Typography variant="h5" color="text.secondary" gutterBottom>
                        No upcoming events found
                    </Typography>
                    <Typography variant="body1" color="text.secondary">
                        Check back later for upcoming events
                    </Typography>
                </Box>
            );
        }

        return (
            <Grid container spacing={3}>
                {displayEvents.map(event => (
                    <Grid item xs={12} sm={6} md={4} key={event.event_id}>
                        <Card
                            sx={{
                                height: '100%',
                                display: 'flex',
                                flexDirection: 'column',
                                transition: 'transform 0.2s, box-shadow 0.2s',
                                '&:hover': {
                                    transform: 'translateY(-4px)',
                                    boxShadow: 6,
                                },
                                position: 'relative'
                            }}
                        >
                            {loading ? (
                                <Skeleton variant="rectangular" height={140} />
                            ) : (
                                <CardMedia
                                    component="img"
                                    height="140"
                                    image={`/api/placeholder/400/140`}
                                    alt={event.name}
                                />
                            )}
                            <CardContent sx={{ flexGrow: 1 }}>
                                {loading ? (
                                    <>
                                        <Skeleton variant="text" height={32} width="80%" />
                                        <Skeleton variant="text" height={24} width="60%" />
                                        <Skeleton variant="text" height={20} width="40%" />
                                        <Skeleton variant="text" height={20} width="100%" sx={{ mt: 1 }} />
                                        <Skeleton variant="text" height={20} width="90%" />
                                    </>
                                ) : (
                                    <>
                                        <Box sx={{ position: 'absolute', top: 12, right: 12, zIndex: 1 }}>
                                            <IconButton
                                                onClick={() => toggleFavorite(event.event_id)}
                                                sx={{
                                                    bgcolor: 'rgba(255,255,255,0.8)',
                                                    '&:hover': { bgcolor: 'rgba(255,255,255,0.9)' }
                                                }}
                                                size="small"
                                            >
                                                {favorites[event.event_id] ?
                                                    <Favorite color="error" /> :
                                                    <FavoriteBorder />
                                                }
                                            </IconButton>
                                        </Box>
                                        <Typography
                                            variant="h6"
                                            component="h2"
                                            gutterBottom
                                            sx={{ fontWeight: 'bold' }}
                                        >
                                            {event.name}
                                        </Typography>
                                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                                            <CalendarToday fontSize="small" color="primary" sx={{ mr: 1 }} />
                                            <Typography variant="body2" color="text.secondary">
                                                {formatDate(event.event_date)}
                                            </Typography>
                                        </Box>
                                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                                            <LocationOn fontSize="small" color="primary" sx={{ mr: 1 }} />
                                            <Typography variant="body2" color="text.secondary">
                                                {event.location || 'No location specified'}
                                            </Typography>
                                        </Box>
                                        <Divider sx={{ my: 1.5 }} />
                                        <Typography variant="body2" color="text.secondary">
                                            {event.description || 'No description provided'}
                                        </Typography>
                                    </>
                                )}
                            </CardContent>
                            <CardActions sx={{ p: 2, pt: 0 }}>
                                {loading ? (
                                    <Skeleton variant="rectangular" height={36} width={120} />
                                ) : (
                                    <Button
                                        variant="contained"
                                        size="small"
                                        color="primary"
                                        sx={{ borderRadius: 4, px: 2 }}
                                    >
                                        View Details
                                    </Button>
                                )}
                            </CardActions>
                        </Card>
                    </Grid>
                ))}
            </Grid>
        );
    };

    const renderPastEvents = () => {
        const displayEvents = loading ? sampleEvents :
            (events && events.past ? events.past : []);

        if (displayEvents.length === 0 && !loading) {
            return (
                <Box sx={{ textAlign: 'center', py: 6 }}>
                    <Typography variant="h5" color="text.secondary" gutterBottom>
                        No past events found
                    </Typography>
                    <Typography variant="body1" color="text.secondary">
                        Events you've attended will appear here
                    </Typography>
                </Box>
            );
        }

        return (
            <Grid container spacing={3}>
                {displayEvents.map(event => (
                    <Grid item xs={12} sm={6} md={4} key={event.event_id}>
                        <Card
                            sx={{
                                height: '100%',
                                display: 'flex',
                                flexDirection: 'column',
                                transition: 'transform 0.2s, box-shadow 0.2s',
                                '&:hover': {
                                    transform: 'translateY(-4px)',
                                    boxShadow: 6,
                                },
                                position: 'relative'
                            }}
                        >
                            {loading ? (
                                <Skeleton variant="rectangular" height={140} />
                            ) : (
                                <CardMedia
                                    component="img"
                                    height="140"
                                    image={`/api/placeholder/400/140`}
                                    alt={event.name}
                                />
                            )}
                            <CardContent sx={{ flexGrow: 1 }}>
                                {loading ? (
                                    <>
                                        <Skeleton variant="text" height={32} width="80%" />
                                        <Skeleton variant="text" height={24} width="60%" />
                                        <Skeleton variant="text" height={20} width="40%" />
                                        <Skeleton variant="text" height={20} width="100%" sx={{ mt: 1 }} />
                                        <Skeleton variant="text" height={20} width="90%" />
                                    </>
                                ) : (
                                    <>
                                        <Box sx={{ position: 'absolute', top: 12, right: 12, zIndex: 1 }}>
                                            <IconButton
                                                onClick={() => toggleFavorite(event.event_id)}
                                                sx={{
                                                    bgcolor: 'rgba(255,255,255,0.8)',
                                                    '&:hover': { bgcolor: 'rgba(255,255,255,0.9)' }
                                                }}
                                                size="small"
                                            >
                                                {favorites[event.event_id] ?
                                                    <Favorite color="error" /> :
                                                    <FavoriteBorder />
                                                }
                                            </IconButton>
                                        </Box>
                                        <Typography
                                            variant="h6"
                                            component="h2"
                                            gutterBottom
                                            sx={{ fontWeight: 'bold' }}
                                        >
                                            {event.name}
                                        </Typography>
                                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                                            <CalendarToday fontSize="small" color="action" sx={{ mr: 1 }} />
                                            <Typography variant="body2" color="text.secondary">
                                                {formatDate(event.event_date)}
                                            </Typography>
                                        </Box>
                                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                                            <LocationOn fontSize="small" color="action" sx={{ mr: 1 }} />
                                            <Typography variant="body2" color="text.secondary">
                                                {event.location || 'No location specified'}
                                            </Typography>
                                        </Box>

                                        {/* Show ratings for past events */}
                                        {event.review_count > 0 && (
                                            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                                                <Rating
                                                    value={parseFloat(event.avg_rating) || 0}
                                                    precision={0.5}
                                                    readOnly
                                                    size="small"
                                                />
                                                <Typography variant="body2" color="text.secondary" sx={{ ml: 1 }}>
                                                    {formatRating(event.avg_rating)} ({event.review_count} {event.review_count === 1 ? 'review' : 'reviews'})
                                                </Typography>
                                            </Box>
                                        )}

                                        <Divider sx={{ my: 1.5 }} />
                                        <Typography variant="body2" color="text.secondary">
                                            {event.description || 'No description provided'}
                                        </Typography>
                                    </>
                                )}
                            </CardContent>
                            <CardActions sx={{ p: 2, pt: 0 }}>
                                {loading ? (
                                    <Skeleton variant="rectangular" height={36} width={120} />
                                ) : (
                                    <Button
                                        variant="contained"
                                        size="small"
                                        color={event.review_count > 0 ? "secondary" : "primary"}
                                        startIcon={event.review_count > 0 ? <Star /> : null}
                                        sx={{ borderRadius: 4, px: 2 }}
                                    >
                                        {event.review_count > 0 ? 'See Reviews' : 'Add Review'}
                                    </Button>
                                )}
                            </CardActions>
                        </Card>
                    </Grid>
                ))}
            </Grid>
        );
    };

    return (
        <Container maxWidth={false} sx={{ width: '100%' }}>
            <Box sx={{ mb: 4, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Typography
                    variant="h4"
                    component="h1"
                    sx={{ fontWeight: 'bold' }}
                >
                    Events
                </Typography>
                <Box sx={{ display: 'flex', gap: 2 }}>
                    <Button
                        variant="contained"
                        color="primary"
                        startIcon={<Add />}
                        onClick={handleOpenCreateEvent}
                    >
                        Create Event
                    </Button>
                    <Button
                        variant="outlined"
                        color="primary"
                        startIcon={<CalendarToday />}
                        onClick={() => {
                            // Dispatch a custom event to navigate to the calendar
                            window.dispatchEvent(new CustomEvent('navigate', {
                                detail: 'calendar'
                            }));
                        }}
                    >
                        View Calendar
                    </Button>
                </Box>
            </Box>

            {error && (
                <Alert
                    severity="warning"
                    sx={{ mb: 4 }}
                >
                    Note: Using fallback data sorting due to API error. {error.message}
                </Alert>
            )}

            <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
                <Tabs
                    value={activeTab}
                    onChange={handleTabChange}
                    aria-label="event tabs"
                    variant="fullWidth"
                >
                    <Tab
                        label="Upcoming Events"
                        icon={<Event />}
                        iconPosition="start"
                    />
                    <Tab
                        label="Past Events"
                        icon={<History />}
                        iconPosition="start"
                    />
                </Tabs>
            </Box>

            {loading && (
                <Box sx={{ display: 'flex', justifyContent: 'center', py: 8 }}>
                    <CircularProgress size={40} />
                </Box>
            )}

            {!loading && (
                activeTab === 0 ? renderUpcomingEvents() : renderPastEvents()
            )}

            {/* Floating action button for mobile */}
            <Tooltip title="Create Event">
                <Fab
                    color="primary"
                    aria-label="add event"
                    sx={{
                        position: 'fixed',
                        bottom: 20,
                        right: 20,
                        display: { xs: 'flex', md: 'none' }
                    }}
                    onClick={handleOpenCreateEvent}
                >
                    <Add />
                </Fab>
            </Tooltip>

            {/* Create Event Dialog */}
            <CreateEventForm
                open={createEventOpen}
                onClose={handleCloseCreateEvent}
                onEventCreated={handleEventCreated}
            />
        </Container>
    );
}

export default EventsList;

================
File: frontend/src/components/LandingPage.jsx
================
import React, { useState } from 'react';
import RegisterForm from './RegisterForm';
import LoginForm from './LoginForm';
import { 
    Box, Typography, Paper, Grid, Container, useTheme,
    Card, CardContent, CardMedia, Button, Stack, Divider,
    Tabs, Tab
} from '@mui/material';
import { 
    EventAvailable, Security, People, BarChart,
    CalendarMonth, Dashboard as DashboardIcon
} from '@mui/icons-material';
import eventIllustration from '../assets/landing.jpg';

const FeatureCard = ({ icon, title, description }) => {
    const theme = useTheme();
    
    return (
        <Card sx={{ 
            height: '100%', 
            display: 'flex', 
            flexDirection: 'column',
            transition: 'transform 0.3s, box-shadow 0.3s',
            '&:hover': {
                transform: 'translateY(-8px)',
                boxShadow: theme.shadows[8],
            },
        }}>
            <CardContent sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', p: 3 }}>
                <Box sx={{ 
                    p: 2, 
                    borderRadius: '50%', 
                    backgroundColor: 'primary.main', 
                    color: 'white',
                    mb: 2
                }}>
                    {icon}
                </Box>
                <Typography variant="h5" component="h3" gutterBottom align="center" sx={{ fontWeight: 'medium' }}>
                    {title}
                </Typography>
                <Typography variant="body1" color="text.secondary" align="center">
                    {description}
                </Typography>
            </CardContent>
        </Card>
    );
};

const LandingPage = ({ onLoginSuccess }) => {
    const theme = useTheme();
    const [authTab, setAuthTab] = useState(0);

    const handleAuthTabChange = (event, newValue) => {
        setAuthTab(newValue);
    };
    
    const features = [
        {
            icon: <EventAvailable fontSize="large" />,
            title: "Event Management",
            description: "Create and manage events with ease. Set dates, locations, and reminders all in one place."
        },
        {
            icon: <People fontSize="large" />,
            title: "Attendee Tracking",
            description: "Track RSVPs, send invitations, and manage your guest list effortlessly."
        },
        {
            icon: <CalendarMonth fontSize="large" />,
            title: "Calendar Integration",
            description: "Sync with your favorite calendar apps to keep all your events organized."
        },
        {
            icon: <BarChart fontSize="large" />,
            title: "Insightful Analytics",
            description: "Get detailed analytics on attendance, engagement, and event performance."
        },
    ];

    return (
        <Container maxWidth="lg">
            {/* Hero Section */}
            <Box sx={{ 
                py: 8, 
                display: 'flex',
                flexDirection: { xs: 'column', md: 'row' },
                alignItems: 'center',
                justifyContent: 'space-between',
                gap: 4
            }}>
                <Box sx={{ maxWidth: 600 }}>
                    <Typography 
                        variant="h2" 
                        component="h1"
                        gutterBottom
                        sx={{ 
                            fontWeight: 'bold',
                            lineHeight: 1.2,
                            fontSize: { xs: '2.5rem', md: '3.5rem' }
                        }}
                    >
                        Plan, Manage, and Host Amazing Events
                    </Typography>
                    <Typography 
                        variant="h5" 
                        color="text.secondary"
                        paragraph
                        sx={{ mb: 4 }}
                    >
                        Evently simplifies event planning with powerful tools for organizers and a seamless experience for attendees.
                    </Typography>
                    <Button 
                        variant="contained" 
                        size="large" 
                        color="primary"
                        sx={{ 
                            py: 1.5, 
                            px: 4,
                            borderRadius: 2
                        }}
                        href="#auth-section"
                    >
                        Get Started
                    </Button>
                </Box>
                <Box 
                    component="img"
                    src={eventIllustration}
                    alt="Event illustration"
                    sx={{
                        width: { xs: '100%', md: '45%' },
                        maxWidth: 500,
                        borderRadius: 4,
                        boxShadow: theme.shadows[5]
                    }}
                />
            </Box>
            
            {/* Features Section */}
            <Box sx={{ py: 8 }}>
                <Typography 
                    variant="h3" 
                    component="h2" 
                    align="center" 
                    gutterBottom
                    sx={{ 
                        fontWeight: 'bold',
                        mb: 6
                    }}
                >
                    Why Choose Evently
                </Typography>
                <Grid container spacing={4}>
                    {features.map((feature, index) => (
                        <Grid item xs={12} sm={6} md={3} key={index}>
                            <FeatureCard {...feature} />
                        </Grid>
                    ))}
                </Grid>
            </Box>
            
            {/* Auth Section */}
            <Box id="auth-section" sx={{ py: 8 }}>
                <Typography 
                    variant="h3" 
                    component="h2" 
                    align="center" 
                    gutterBottom
                    sx={{ 
                        fontWeight: 'bold',
                        mb: 6
                    }}
                >
                    Get Started Today
                </Typography>
                <Grid container spacing={4} justifyContent="center">
                    <Grid item xs={12} md={6}>
                        <Paper 
                            elevation={3} 
                            sx={{ 
                                p: 4, 
                                height: '100%',
                                borderRadius: 2,
                                transition: 'transform 0.3s',
                                '&:hover': {
                                    transform: 'scale(1.02)',
                                }
                            }}
                        >
                            <Tabs 
                                value={authTab} 
                                onChange={handleAuthTabChange} 
                                centered 
                                sx={{ mb: 3 }}
                            >
                                <Tab label="Login" />
                                <Tab label="Create Account" />
                            </Tabs>
                            {authTab === 0 ? (
                                <LoginForm onLoginSuccess={onLoginSuccess} />
                            ) : (
                                <RegisterForm onLoginSuccess={onLoginSuccess} />
                            )}
                        </Paper>
                    </Grid>
                </Grid>
            </Box>
            
            {/* Footer */}
            <Divider sx={{ my: 4 }} />
            <Box component="footer" sx={{ py: 4, textAlign: 'center' }}>
                <Typography variant="body2" color="text.secondary">
                    &copy; 2025 Evently. All rights reserved.
                </Typography>
            </Box>
        </Container>
    );
};

export default LandingPage;

================
File: frontend/src/components/LoginForm.jsx
================
import React, { useState } from 'react';
import {
    TextField, Button, Typography, Box, Alert,
    InputAdornment, IconButton, CircularProgress
} from '@mui/material';
import {
    Visibility, VisibilityOff, Login as LoginIcon
} from '@mui/icons-material';
import { fetchApi } from '../utils/api';

const LoginForm = ({ onLoginSuccess }) => {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const [showPassword, setShowPassword] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setLoading(true);
        
        try {
            const data = await fetchApi('/api/login', {
                method: 'POST',
                body: JSON.stringify({ username, password })
            });
    
            // Store token and handle login success
            localStorage.setItem('authToken', data.token);
            localStorage.setItem('username', data.username);
            onLoginSuccess(data.username, data.role);
            
        } catch (error) {
            setError(error.message || 'Login failed. Please check your credentials.');
            console.error('Login Error:', error);
        } finally {
            setLoading(false);
        }
    };

    return (
        <Box sx={{ maxWidth: 400, margin: 'auto' }}>
            <Typography
                variant="h4"
                component="h1"
                align="center"
                gutterBottom
                sx={{ fontWeight: 'bold', mb: 3 }}
            >
                Welcome Back
            </Typography>

            {error && (
                <Alert
                    severity="error"
                    sx={{ mb: 2 }}
                    onClose={() => setError('')}
                >
                    {error}
                </Alert>
            )}

            <Box component="form" onSubmit={handleSubmit} sx={{ mt: 2 }}>
                <TextField
                    label="Username"
                    variant="outlined"
                    fullWidth
                    margin="normal"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                    disabled={loading}
                    required
                    autoFocus
                />

                <TextField
                    label="Password"
                    type={showPassword ? 'text' : 'password'}
                    variant="outlined"
                    fullWidth
                    margin="normal"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    disabled={loading}
                    required
                    InputProps={{
                        endAdornment: (
                            <InputAdornment position="end">
                                <IconButton
                                    onClick={() => setShowPassword(!showPassword)}
                                    edge="end"
                                    aria-label="toggle password visibility"
                                >
                                    {showPassword ? <VisibilityOff /> : <Visibility />}
                                </IconButton>
                            </InputAdornment>
                        )
                    }}
                />

                <Button
                    type="submit"
                    variant="contained"
                    color="primary"
                    fullWidth
                    size="large"
                    disabled={loading}
                    startIcon={loading ? <CircularProgress size={20} color="inherit" /> : <LoginIcon />}
                    sx={{
                        mt: 3,
                        mb: 2,
                        py: 1.5,
                        fontWeight: 'bold',
                        '&:hover': {
                            backgroundColor: 'primary.dark'
                        }
                    }}
                >
                    {loading ? 'Logging in...' : 'Login'}
                </Button>
            </Box>
        </Box>
    );
};

export default LoginForm;

================
File: frontend/src/components/RegisterForm.jsx
================
import React, { useState } from 'react';
import {
    TextField, Button, Typography, Box, Alert,
    InputAdornment, IconButton, CircularProgress
} from '@mui/material';
import {
    Visibility, VisibilityOff, PersonAdd
} from '@mui/icons-material';
import { fetchApi } from '../utils/api';

const RegisterForm = ({ onLoginSuccess }) => {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [email, setEmail] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const [showPassword, setShowPassword] = useState(false);
    const [showConfirmPassword, setShowConfirmPassword] = useState(false);
    const [successMessage, setSuccessMessage] = useState('');

    // Centralized API URL configuration
    const API_BASE_URL = import.meta.env.VITE_API_URL || 'https://evently-production-cd21.up.railway.app';

    const validateForm = () => {
        if (!username) {
            setError('Username is required');
            return false;
        }

        if (!email || !email.includes('@')) {
            setError('A valid email address is required');
            return false;
        }

        if (password.length < 6) {
            setError('Password must be at least 6 characters long');
            return false;
        }

        if (password !== confirmPassword) {
            setError('Passwords do not match');
            return false;
        }

        return true;
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setLoading(true);
        setError('');

        if (!validateForm()) {
            setLoading(false);
            return;
        }

        try {
            const data = await fetchApi('/api/register', {
                method: 'POST',
                body: JSON.stringify({ username, password, email })
            });

            // Successful registration
            setUsername('');
            setPassword('');
            setConfirmPassword('');
            setEmail('');

            // After successful registration, you need to log the user in
            // Make a login request to get a token
            const loginData = await fetchApi('/api/login', {
                method: 'POST',
                body: JSON.stringify({ username, password })
            });

            // Store the token in localStorage
            localStorage.setItem('authToken', loginData.token);
            localStorage.setItem('username', loginData.username);

            // Trigger login success callback
            setTimeout(() => {
                onLoginSuccess(username, loginData.role);
            }, 1500);
            setSuccessMessage('Registration successful! Logging you in...');

        } catch (error) {
            setError(error.message || 'Registration failed. Please try again.');
            console.error('Registration Error:', error);
        } finally {
            setLoading(false);
        }
    };

    return (
        <Box sx={{ maxWidth: 400, margin: 'auto' }}>
            <Typography
                variant="h4"
                component="h1"
                align="center"
                gutterBottom
                sx={{ fontWeight: 'bold', mb: 3 }}
            >
                Create Your Account
            </Typography>

            {error && (
                <Alert
                    severity="error"
                    sx={{ mb: 2 }}
                    onClose={() => setError('')}
                >
                    {error}
                </Alert>
            )}

            {successMessage && (
                <Alert
                    severity="success"
                    sx={{ mb: 2 }}
                >
                    {successMessage}
                </Alert>
            )}

            <Box component="form" onSubmit={handleSubmit} sx={{ mt: 2 }}>
                <TextField
                    label="Username"
                    variant="outlined"
                    fullWidth
                    margin="normal"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                    disabled={loading}
                    required
                    autoFocus
                />

                <TextField
                    label="Email"
                    type="email"
                    variant="outlined"
                    fullWidth
                    margin="normal"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    disabled={loading}
                    required
                />

                <TextField
                    label="Password"
                    type={showPassword ? 'text' : 'password'}
                    variant="outlined"
                    fullWidth
                    margin="normal"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    disabled={loading}
                    required
                    InputProps={{
                        endAdornment: (
                            <InputAdornment position="end">
                                <IconButton
                                    onClick={() => setShowPassword(!showPassword)}
                                    edge="end"
                                    aria-label="toggle password visibility"
                                >
                                    {showPassword ? <VisibilityOff /> : <Visibility />}
                                </IconButton>
                            </InputAdornment>
                        )
                    }}
                />

                <TextField
                    label="Confirm Password"
                    type={showConfirmPassword ? 'text' : 'password'}
                    variant="outlined"
                    fullWidth
                    margin="normal"
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    disabled={loading}
                    required
                    error={password !== confirmPassword && confirmPassword !== ''}
                    helperText={password !== confirmPassword && confirmPassword !== '' ? 'Passwords do not match' : ''}
                    InputProps={{
                        endAdornment: (
                            <InputAdornment position="end">
                                <IconButton
                                    onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                                    edge="end"
                                    aria-label="toggle confirm password visibility"
                                >
                                    {showConfirmPassword ? <VisibilityOff /> : <Visibility />}
                                </IconButton>
                            </InputAdornment>
                        )
                    }}
                />

                <Button
                    type="submit"
                    variant="contained"
                    color="secondary"
                    fullWidth
                    size="large"
                    disabled={loading}
                    startIcon={loading ? <CircularProgress size={20} color="inherit" /> : <PersonAdd />}
                    sx={{
                        mt: 3,
                        mb: 2,
                        py: 1.5,
                        fontWeight: 'bold',
                        '&:hover': {
                            backgroundColor: 'secondary.dark'
                        }
                    }}
                >
                    {loading ? 'Registering...' : 'Create Account'}
                </Button>
            </Box>
        </Box>
    );
};

export default RegisterForm;

================
File: frontend/src/components/ReviewDialog.jsx
================
// ReviewDialog.jsx - A standalone component to manage reviews
import React, { useState, useEffect } from 'react';
import {
    Dialog, DialogTitle, DialogContent, DialogActions,
    Button, Typography, Box, Avatar, Rating, TextField,
    Divider, CircularProgress, Chip, IconButton, Alert,
    Select, MenuItem, FormControl, InputLabel, Paper,
    Tabs, Tab
} from '@mui/material';
import {
    Edit, Delete, Flag, Check, Close, Add,
    Sort, FilterList, Search, Refresh, MoreVert
} from '@mui/icons-material';
import StarRating from './StarRating';

const ReviewDialog = ({ 
    open, 
    onClose, 
    eventId, 
    eventName, 
    eventDate, 
    eventLocation,
    initialRating,
    reviewCount
}) => {
    const [reviews, setReviews] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [successMessage, setSuccessMessage] = useState(null);
    const [editingReview, setEditingReview] = useState(null);
    const [newReview, setNewReview] = useState({
        rating: 0,
        review_text: ''
    });
    const [showAddReview, setShowAddReview] = useState(false);
    const [currentTab, setCurrentTab] = useState(0);
    
    // Sorting and filtering
    const [sortBy, setSortBy] = useState('created_at');
    const [sortOrder, setSortOrder] = useState('desc');
    const [filterRating, setFilterRating] = useState('all');
    const [showFilters, setShowFilters] = useState(false);
    
    // Get JWT token from localStorage
    const getToken = () => {
        return localStorage.getItem('authToken');
    };

    // Get current user ID from JWT
    const getCurrentUserId = () => {
        const token = getToken();
        if (!token) return null;
        
        try {
            // JWT token consists of three parts separated by dots
            const payload = token.split('.')[1];
            // Decode the base64 payload
            const decodedPayload = JSON.parse(atob(payload));
            return decodedPayload.userId;
        } catch (error) {
            console.error('Error decoding JWT token:', error);
            return null;
        }
    };
    
    const currentUserId = getCurrentUserId();

    // Format date for display
    const formatDate = (dateString) => {
        const date = new Date(dateString);
        return new Intl.DateTimeFormat('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric'
        }).format(date);
    };

    // Fetch reviews for the event
    const fetchReviews = async () => {
        if (!eventId) return;
        
        setLoading(true);
        setError(null);
        
        try {
            const token = getToken();
            if (!token) {
                throw new Error('No authentication token found');
            }

            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };
            
            // Build URL with query parameters for sorting and filtering
            let url = `http://localhost:5000/api/events/${eventId}/reviews?sort_by=${sortBy}&sort_order=${sortOrder}`;
            
            if (filterRating !== 'all') {
                url += `&rating=${filterRating}`;
            }

            const response = await fetch(url, { headers });
            
            if (!response.ok) {
                throw new Error(`Failed to fetch reviews: ${response.status}`);
            }
            
            const data = await response.json();
            setReviews(data);
        } catch (error) {
            console.error('Error fetching reviews:', error);
            setError(error.message);
            
            // Fallback to empty array
            setReviews([]);
        } finally {
            setLoading(false);
        }
    };
    

    // Load reviews when the dialog opens or filters change
    useEffect(() => {
        if (open && eventId) {
            fetchReviews();
        }
    }, [open, eventId, sortBy, sortOrder, filterRating]);
    
    // Load analytics when tab changes
    useEffect(() => {
        if (open && eventId && currentTab === 1) {
            fetchAnalytics();
        }
    }, [open, eventId, currentTab, reviews]);

    // Handle adding a new review
    const handleAddReview = async () => {
        if (newReview.rating === 0) {
            setError('Please select a rating');
            return;
        }
        
        setLoading(true);
        setError(null);
        setSuccessMessage(null);
        
        try {
            const token = getToken();
            if (!token) {
                throw new Error('No authentication token found');
            }

            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };

            const response = await fetch(`http://localhost:5000/api/events/${eventId}/reviews`, {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    rating: newReview.rating,
                    review_text: newReview.review_text
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Failed to add review: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Add the new review to the list
            setReviews([data, ...reviews]);
            
            // Reset form
            setNewReview({ rating: 0, review_text: '' });
            setShowAddReview(false);
            setSuccessMessage('Review added successfully!');
            
            // Success message disappears after 3 seconds
            setTimeout(() => setSuccessMessage(null), 3000);
        } catch (error) {
            console.error('Error adding review:', error);
            setError(error.message);
        } finally {
            setLoading(false);
        }
    };

    // Handle updating a review
    const handleUpdateReview = async () => {
        if (!editingReview) return;
        
        setLoading(true);
        setError(null);
        setSuccessMessage(null);
        
        try {
            const token = getToken();
            if (!token) {
                throw new Error('No authentication token found');
            }

            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };

            const response = await fetch(`http://localhost:5000/api/reviews/${editingReview.review_id}`, {
                method: 'PUT',
                headers,
                body: JSON.stringify({
                    rating: editingReview.rating,
                    review_text: editingReview.review_text
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Failed to update review: ${response.status}`);
            }
            
            const updatedReview = await response.json();
            
            // Update the review in the list
            setReviews(reviews.map(review => 
                review.review_id === updatedReview.review_id ? updatedReview : review
            ));
            
            setEditingReview(null);
            setSuccessMessage('Review updated successfully!');
            
            // Success message disappears after 3 seconds
            setTimeout(() => setSuccessMessage(null), 3000);
        } catch (error) {
            console.error('Error updating review:', error);
            setError(error.message);
        } finally {
            setLoading(false);
        }
    };

    // Handle deleting a review
    const handleDeleteReview = async (reviewId) => {
        if (!reviewId) return;
        
        if (!window.confirm('Are you sure you want to delete this review?')) {
            return;
        }
        
        setLoading(true);
        setError(null);
        setSuccessMessage(null);
        
        try {
            const token = getToken();
            if (!token) {
                throw new Error('No authentication token found');
            }

            const headers = {
                'Authorization': `Bearer ${token}`
            };

            const response = await fetch(`http://localhost:5000/api/reviews/${reviewId}`, {
                method: 'DELETE',
                headers
            });
            
            if (!response.ok) {
                throw new Error(`Failed to delete review: ${response.status}`);
            }
            
            // Remove the review from the list
            setReviews(reviews.filter(review => review.review_id !== reviewId));
            setSuccessMessage('Review deleted successfully!');
            
            // Success message disappears after 3 seconds
            setTimeout(() => setSuccessMessage(null), 3000);
        } catch (error) {
            console.error('Error deleting review:', error);
            setError(error.message);
        } finally {
            setLoading(false);
        }
    };

    // Handle changes to new review
    const handleNewReviewChange = (field, value) => {
        setNewReview({
            ...newReview,
            [field]: value
        });
    };

    // Handle changes to editing review
    const handleEditingReviewChange = (field, value) => {
        setEditingReview({
            ...editingReview,
            [field]: value
        });
    };

    // Handle tab change
    const handleTabChange = (event, newValue) => {
        setCurrentTab(newValue);
    };

    // Render tabs content
    const renderTabContent = () => {
        switch (currentTab) {
            case 0: // Reviews tab
                return renderReviewsTab();
            case 1: // Analytics tab
                return renderAnalyticsTab();
            default:
                return renderReviewsTab();
        }
    };

    // Render reviews tab
    const renderReviewsTab = () => {
        return (
            <Box>
                {/* Sorting and filtering controls */}
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                    <Button
                        startIcon={<Add />}
                        color="primary"
                        onClick={() => setShowAddReview(!showAddReview)}
                        disabled={loading}
                    >
                        Add Review
                    </Button>
                    <Box>
                        <IconButton 
                            onClick={() => setShowFilters(!showFilters)}
                            color={showFilters ? "primary" : "default"}
                        >
                            <FilterList />
                        </IconButton>
                        <IconButton onClick={fetchReviews} disabled={loading}>
                            <Refresh />
                        </IconButton>
                    </Box>
                </Box>
                
                {/* Filters */}
                {showFilters && (
                    <Paper sx={{ p: 2, mb: 2 }}>
                        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2 }}>
                            <FormControl sx={{ minWidth: 120 }} size="small">
                                <InputLabel id="filter-rating-label">Rating</InputLabel>
                                <Select
                                    labelId="filter-rating-label"
                                    value={filterRating}
                                    label="Rating"
                                    onChange={(e) => setFilterRating(e.target.value)}
                                >
                                    <MenuItem value="all">All Ratings</MenuItem>
                                    <MenuItem value="5">5 Stars</MenuItem>
                                    <MenuItem value="4">4 Stars</MenuItem>
                                    <MenuItem value="3">3 Stars</MenuItem>
                                    <MenuItem value="2">2 Stars</MenuItem>
                                    <MenuItem value="1">1 Star</MenuItem>
                                </Select>
                            </FormControl>
                            
                            <FormControl sx={{ minWidth: 120 }} size="small">
                                <InputLabel id="sort-by-label">Sort By</InputLabel>
                                <Select
                                    labelId="sort-by-label"
                                    value={sortBy}
                                    label="Sort By"
                                    onChange={(e) => setSortBy(e.target.value)}
                                >
                                    <MenuItem value="created_at">Date</MenuItem>
                                    <MenuItem value="rating">Rating</MenuItem>
                                </Select>
                            </FormControl>
                            
                            <FormControl sx={{ minWidth: 120 }} size="small">
                                <InputLabel id="sort-order-label">Order</InputLabel>
                                <Select
                                    labelId="sort-order-label"
                                    value={sortOrder}
                                    label="Order"
                                    onChange={(e) => setSortOrder(e.target.value)}
                                >
                                    <MenuItem value="desc">Descending</MenuItem>
                                    <MenuItem value="asc">Ascending</MenuItem>
                                </Select>
                            </FormControl>
                        </Box>
                    </Paper>
                )}
                
                {/* Add review form */}
                {showAddReview && (
                    <Paper sx={{ p: 2, mb: 3 }}>
                        <Typography variant="h6" gutterBottom>
                            Write a Review
                        </Typography>
                        <Box sx={{ mb: 2 }}>
                            <Typography variant="body2" gutterBottom>
                                Rating
                            </Typography>
                            <StarRating 
                                value={newReview.rating} 
                                onChange={(value) => handleNewReviewChange('rating', value)}
                                size="large"
                                precision={0.5}
                                showValue
                                hoverLabels={[
                                    'Poor', 'Fair', 'Good', 'Very Good', 'Excellent'
                                ]}
                            />
                        </Box>
                        <TextField
                            label="Your Review"
                            multiline
                            rows={4}
                            value={newReview.review_text}
                            onChange={(e) => handleNewReviewChange('review_text', e.target.value)}
                            fullWidth
                            variant="outlined"
                            placeholder="Share your experience with this event..."
                            sx={{ mb: 2 }}
                        />
                        <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
                            <Button 
                                onClick={() => {
                                    setShowAddReview(false);
                                    setNewReview({ rating: 0, review_text: '' });
                                }}
                            >
                                Cancel
                            </Button>
                            <Button 
                                variant="contained" 
                                color="primary"
                                onClick={handleAddReview}
                                disabled={loading || newReview.rating === 0}
                            >
                                Submit Review
                            </Button>
                        </Box>
                    </Paper>
                )}
                
                {/* Success/Error messages */}
                {successMessage && (
                    <Alert severity="success" sx={{ mb: 2 }}>
                        {successMessage}
                    </Alert>
                )}
                
                {error && (
                    <Alert severity="error" sx={{ mb: 2 }}>
                        {error}
                    </Alert>
                )}
                
                {/* Reviews list */}
                {loading ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                        <CircularProgress />
                    </Box>
                ) : reviews.length === 0 ? (
                    <Box sx={{ textAlign: 'center', py: 4 }}>
                        <Typography variant="body1" color="text.secondary">
                            No reviews yet. Be the first to review this event!
                        </Typography>
                    </Box>
                ) : (
                    <Box>
                        {reviews.map((review) => (
                            <Box key={review.review_id} sx={{ mb: 3 }}>
                                {editingReview && editingReview.review_id === review.review_id ? (
                                    // Edit mode
                                    <Paper sx={{ p: 2 }}>
                                        <Box sx={{ mb: 2 }}>
                                            <Typography variant="body2" gutterBottom>
                                                Rating
                                            </Typography>
                                            <StarRating 
                                                value={editingReview.rating} 
                                                onChange={(value) => handleEditingReviewChange('rating', value)}
                                                size="large"
                                                precision={0.5}
                                                showValue
                                            />
                                        </Box>
                                        <TextField
                                            label="Your Review"
                                            multiline
                                            rows={3}
                                            value={editingReview.review_text}
                                            onChange={(e) => handleEditingReviewChange('review_text', e.target.value)}
                                            fullWidth
                                            variant="outlined"
                                            sx={{ mb: 2 }}
                                        />
                                        <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
                                            <Button 
                                                onClick={() => setEditingReview(null)}
                                            >
                                                Cancel
                                            </Button>
                                            <Button 
                                                variant="contained" 
                                                color="primary"
                                                onClick={handleUpdateReview}
                                                disabled={loading}
                                            >
                                                Update Review
                                            </Button>
                                        </Box>
                                    </Paper>
                                ) : (
                                    // View mode
                                    <Paper sx={{ p: 2 }}>
                                        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                                <Avatar sx={{ mr: 1 }}>
                                                    {review.username?.charAt(0).toUpperCase() || 'U'}
                                                </Avatar>
                                                <Box>
                                                    <Typography variant="subtitle1">
                                                        {review.username || 'Anonymous'}
                                                    </Typography>
                                                    <Typography variant="caption" color="text.secondary">
                                                        {formatDate(review.created_at)}
                                                    </Typography>
                                                </Box>
                                            </Box>
                                            {/* Show edit/delete for user's own reviews */}
                                            {currentUserId && review.user_id === currentUserId && (
                                                <Box>
                                                    <IconButton 
                                                        size="small" 
                                                        onClick={() => setEditingReview(review)}
                                                        sx={{ ml: 1 }}
                                                    >
                                                        <Edit fontSize="small" />
                                                    </IconButton>
                                                    <IconButton 
                                                        size="small" 
                                                        onClick={() => handleDeleteReview(review.review_id)}
                                                        sx={{ ml: 1 }}
                                                        color="error"
                                                    >
                                                        <Delete fontSize="small" />
                                                    </IconButton>
                                                </Box>
                                            )}
                                        </Box>
                                        <Box sx={{ mb: 1 }}>
                                            <StarRating value={review.rating} readOnly size="small" />
                                        </Box>
                                        <Typography variant="body2" color="text.secondary">
                                            {review.review_text || "No comment provided."}
                                        </Typography>
                                    </Paper>
                                )}
                            </Box>
                        ))}
                    </Box>
                )}
            </Box>
        );
    };

    // Render analytics tab
    const renderAnalyticsTab = () => {
        if (loadingAnalytics) {
            return (
                <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                    <CircularProgress />
                </Box>
            );
        }
        
        if (!analytics) {
            return (
                <Box sx={{ textAlign: 'center', py: 4 }}>
                    <Typography variant="body1" color="text.secondary">
                        No analytics available
                    </Typography>
                </Box>
            );
        }
        
        const { analytics: stats, recentReviews } = analytics;
        
        // Calculate percentages for distribution
        const totalReviews = stats.total_reviews || 1; // Avoid division by zero
        const ratings = [
            { stars: 5, count: stats.five_star, percent: (stats.five_star / totalReviews) * 100 },
            { stars: 4, count: stats.four_star, percent: (stats.four_star / totalReviews) * 100 },
            { stars: 3, count: stats.three_star, percent: (stats.three_star / totalReviews) * 100 },
            { stars: 2, count: stats.two_star, percent: (stats.two_star / totalReviews) * 100 },
            { stars: 1, count: stats.one_star, percent: (stats.one_star / totalReviews) * 100 }
        ];
        
        return (
            <Box>
                {/* Summary stats */}
                <Paper sx={{ p: 2, mb: 3 }}>
                    <Typography variant="h6" gutterBottom>
                        Review Summary
                    </Typography>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                        <Box sx={{ textAlign: 'center' }}>
                            <Typography variant="h4" color="primary.main">
                                {stats.average_rating ? stats.average_rating.toFixed(1) : '0.0'}
                            </Typography>
                            <Typography variant="body2" color="text.secondary">
                                Average Rating
                            </Typography>
                        </Box>
                        <Box sx={{ textAlign: 'center' }}>
                            <Typography variant="h4" color="primary.main">
                                {stats.total_reviews || 0}
                            </Typography>
                            <Typography variant="body2" color="text.secondary">
                                Total Reviews
                            </Typography>
                        </Box>
                        <Box sx={{ textAlign: 'center' }}>
                            <Typography variant="h4" color="success.main">
                                {Math.round((stats.positive_reviews / (totalReviews || 1)) * 100)}%
                            </Typography>
                            <Typography variant="body2" color="text.secondary">
                                Positive
                            </Typography>
                        </Box>
                    </Box>
                </Paper>
                
                {/* Rating distribution */}
                <Paper sx={{ p: 2, mb: 3 }}>
                    <Typography variant="h6" gutterBottom>
                        Rating Distribution
                    </Typography>
                    {ratings.map((rating) => (
                        <Box key={rating.stars} sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                            <Box sx={{ width: '80px', display: 'flex', alignItems: 'center' }}>
                                <Typography variant="body2" sx={{ mr: 1 }}>
                                    {rating.stars} stars
                                </Typography>
                            </Box>
                            <Box sx={{ flexGrow: 1, mr: 2 }}>
                                <Box 
                                    sx={{ 
                                        height: 12, 
                                        bgcolor: 'grey.300', 
                                        borderRadius: 1,
                                        overflow: 'hidden'
                                    }}
                                >
                                    <Box
                                        sx={{
                                            height: '100%',
                                            width: `${rating.percent}%`,
                                            bgcolor: rating.stars >= 4 ? 'success.main' : 
                                                    rating.stars === 3 ? 'warning.main' : 'error.main',
                                            transition: 'width 1s ease-in-out'
                                        }}
                                    />
                                </Box>
                            </Box>
                            <Typography variant="body2" color="text.secondary" sx={{ minWidth: '60px' }}>
                                {rating.count} ({Math.round(rating.percent)}%)
                            </Typography>
                        </Box>
                    ))}
                </Paper>
                
                {/* Recent reviews */}
                <Paper sx={{ p: 2 }}>
                    <Typography variant="h6" gutterBottom>
                        Recent Reviews
                    </Typography>
                    {recentReviews && recentReviews.length > 0 ? (
                        recentReviews.map((review) => (
                            <Box key={review.review_id} sx={{ mb: 2 }}>
                                <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                                    <Avatar sx={{ width: 32, height: 32, mr: 1 }}>
                                        {review.username?.charAt(0).toUpperCase() || 'U'}
                                    </Avatar>
                                    <Typography variant="subtitle2">
                                        {review.username || 'Anonymous'}
                                    </Typography>
                                    <Box sx={{ ml: 'auto' }}>
                                        <StarRating value={review.rating} readOnly size="small" />
                                    </Box>
                                </Box>
                                <Typography variant="body2" color="text.secondary">
                                    {review.review_text || "No comment provided."}
                                </Typography>
                                <Divider sx={{ mt: 1 }} />
                            </Box>
                        ))
                    ) : (
                        <Typography variant="body2" color="text.secondary">
                            No recent reviews available
                        </Typography>
                    )}
                </Paper>
            </Box>
        );
    };

    return (
        <Dialog
            open={open}
            onClose={onClose}
            fullWidth
            maxWidth="md"
            scroll="paper"
        >
            <DialogTitle>
                <Typography variant="h6">{eventName || 'Event Reviews'}</Typography>
                <Typography variant="subtitle2" color="text.secondary">
                    {eventDate && formatDate(eventDate)} â€¢ {eventLocation || 'No location'}
                </Typography>
                <Box sx={{ display: 'flex', alignItems: 'center', mt: 1 }}>
                    <StarRating 
                        value={initialRating || 0} 
                        readOnly 
                        size="small"
                    />
                    <Typography variant="body2" color="text.secondary" sx={{ ml: 1 }}>
                        {initialRating ? initialRating.toFixed(1) : '0.0'} ({reviewCount || 0} reviews)
                    </Typography>
                </Box>
            </DialogTitle>
            
            <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
                <Tabs value={currentTab} onChange={handleTabChange} aria-label="review tabs">
                    <Tab label="Reviews" />
                    <Tab label="Analytics" />
                </Tabs>
            </Box>
            
            <DialogContent dividers>
                {renderTabContent()}
            </DialogContent>
            
            <DialogActions>
                <Button onClick={onClose}>Close</Button>
            </DialogActions>
        </Dialog>
    );
};

export default ReviewDialog;

================
File: frontend/src/components/SimpleEventCalendar.jsx
================
import React, { useState, useEffect } from 'react';
import { 
    Box, Typography, Paper, Button, IconButton, Grid, 
    Card, CardContent, Chip, Divider, CircularProgress,
    Dialog, DialogTitle, DialogContent, DialogActions,
    Alert, useTheme, useMediaQuery, TextField, MenuItem,
    FormControl, InputLabel, Select, Tooltip
} from '@mui/material';
import { 
    ChevronLeft, ChevronRight, CalendarMonth, 
    Event, FilterList, LocationOn, AccessTime, Share,
    Add, Today, Download
} from '@mui/icons-material';

// Function to get the days in a month
const getDaysInMonth = (year, month) => {
    return new Date(year, month + 1, 0).getDate();
};

// Function to get the first day of the month (0 = Sunday, 1 = Monday, etc.)
const getFirstDayOfMonth = (year, month) => {
    return new Date(year, month, 1).getDay();
};

function SimpleEventCalendar() {
    const [events, setEvents] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [selectedDate, setSelectedDate] = useState(new Date());
    const [selectedEvent, setSelectedEvent] = useState(null);
    const [eventDetailsOpen, setEventDetailsOpen] = useState(false);
    const [showFilters, setShowFilters] = useState(false);
    const [categoryFilter, setCategoryFilter] = useState('all');
    const [categories, setCategories] = useState([]);
    const [currentYear, setCurrentYear] = useState(new Date().getFullYear());
    const [currentMonth, setCurrentMonth] = useState(new Date().getMonth());
    const [selectedDay, setSelectedDay] = useState(new Date().getDate());
    const [dayEvents, setDayEvents] = useState([]);
    
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    // Get token from localStorage
    const getToken = () => {
        return localStorage.getItem('authToken');
    };

    // Format date (YYYY-MM-DD)
    const formatDateISO = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    };

    // Format date for display
    const formatDateForDisplay = (dateString) => {
        const date = new Date(dateString);
        const options = { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        };
        return date.toLocaleDateString('en-US', options);
    };

    // Format time for display
    const formatTimeForDisplay = (dateString) => {
        const date = new Date(dateString);
        const options = { hour: '2-digit', minute: '2-digit' };
        return date.toLocaleTimeString('en-US', options);
    };

    useEffect(() => {
        const fetchEvents = async () => {
            setLoading(true);
            try {
                const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
                const response = await fetch(`${apiUrl}/api/events`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                setEvents(data);
                setLoading(false);
            } catch (e) {
                setError(e.message);
                setLoading(false);
                console.error("Error fetching events:", e);
            }
        };
    
        const fetchCategories = async () => {
            try {
                const apiUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000';
                const response = await fetch(`${apiUrl}/api/categories`);
                if (response.ok) {
                    const data = await response.json();
                    setCategories(data);
                }
            } catch (error) {
                console.error("Error fetching categories:", error);
            }
        };
    
        fetchEvents();
        fetchCategories();
    }, []);

    // Filter events for selected day
    useEffect(() => {
        if (events.length > 0) {
            const date = new Date(currentYear, currentMonth, selectedDay);
            const dateStr = formatDateISO(date);
            
            // Filter events for the selected day
            const filteredEvents = events.filter(event => {
                const eventDate = new Date(event.event_date);
                const eventDateStr = formatDateISO(eventDate);
                const categoryMatches = categoryFilter === 'all' || 
                                      event.category_id === parseInt(categoryFilter);
                
                return eventDateStr === dateStr && categoryMatches;
            });
            
            setDayEvents(filteredEvents);
        }
    }, [selectedDay, currentMonth, currentYear, events, categoryFilter]);

    // Go to previous month
    const goToPreviousMonth = () => {
        if (currentMonth === 0) {
            setCurrentMonth(11);
            setCurrentYear(currentYear - 1);
        } else {
            setCurrentMonth(currentMonth - 1);
        }
        setSelectedDay(1);
    };

    // Go to next month
    const goToNextMonth = () => {
        if (currentMonth === 11) {
            setCurrentMonth(0);
            setCurrentYear(currentYear + 1);
        } else {
            setCurrentMonth(currentMonth + 1);
        }
        setSelectedDay(1);
    };

    // Go to today
    const goToToday = () => {
        const today = new Date();
        setCurrentYear(today.getFullYear());
        setCurrentMonth(today.getMonth());
        setSelectedDay(today.getDate());
    };

    // Handle day selection
    const handleDayClick = (day) => {
        setSelectedDay(day);
    };

    // Handle event click
    const handleEventClick = (event) => {
        setSelectedEvent(event);
        setEventDetailsOpen(true);
    };

    // Add event to Google Calendar
    const addToCalendar = (event) => {
        const { name, description, location, event_date } = event;
        const eventStart = new Date(event_date);
        // Default duration 1 hour
        const eventEnd = new Date(eventStart.getTime() + 60 * 60 * 1000);
        
        // Format dates for Google Calendar
        const formatGoogleDate = (date) => {
            return date.toISOString().replace(/-|:|\.\d\d\d/g, '');
        };
        
        // Create Google Calendar URL
        const googleCalendarUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(name)}&dates=${formatGoogleDate(eventStart)}/${formatGoogleDate(eventEnd)}&details=${encodeURIComponent(description || '')}&location=${encodeURIComponent(location || '')}&sf=true&output=xml`;
        
        // Open in new window
        window.open(googleCalendarUrl, '_blank');
    };

    // Get category color
    const getCategoryColor = (categoryId) => {
        // Define a set of colors for categories
        const colors = [
            '#4caf50', // Green
            '#2196f3', // Blue
            '#f44336', // Red
            '#ff9800', // Orange
            '#9c27b0', // Purple
            '#00bcd4', // Cyan
            '#795548', // Brown
            '#607d8b'  // Blue-grey
        ];
        
        // Use modulo to cycle through colors if we have more categories than colors
        return colors[categoryId % colors.length];
    };

    // Check if a date has events
    const dateHasEvents = (year, month, day) => {
        const date = new Date(year, month, day);
        const dateStr = formatDateISO(date);
        
        return events.some(event => {
            const eventDate = new Date(event.event_date);
            const eventDateStr = formatDateISO(eventDate);
            return eventDateStr === dateStr;
        });
    };

    // Render calendar
    const renderCalendar = () => {
        const daysInMonth = getDaysInMonth(currentYear, currentMonth);
        const firstDayOfMonth = getFirstDayOfMonth(currentYear, currentMonth);
        
        // Generate days of the week
        const daysOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        
        // Generate calendar days
        const days = [];
        
        // Add empty cells for days before the first day of the month
        for (let i = 0; i < firstDayOfMonth; i++) {
            days.push(<Grid item key={`empty-${i}`} xs={12/7}><Box sx={{ height: 40 }}></Box></Grid>);
        }
        
        // Add cells for each day of the month
        for (let day = 1; day <= daysInMonth; day++) {
            const isToday = 
                currentYear === new Date().getFullYear() && 
                currentMonth === new Date().getMonth() && 
                day === new Date().getDate();
                
            const isSelected = day === selectedDay;
            const hasEvents = dateHasEvents(currentYear, currentMonth, day);
            
            days.push(
                <Grid item key={day} xs={12/7}>
                    <Box 
                        onClick={() => handleDayClick(day)}
                        sx={{
                            height: 40,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            cursor: 'pointer',
                            borderRadius: '50%',
                            position: 'relative',
                            bgcolor: isSelected ? 'primary.main' : isToday ? 'primary.light' : 'transparent',
                            color: isSelected ? 'white' : 'inherit',
                            '&:hover': {
                                bgcolor: isSelected ? 'primary.dark' : 'action.hover'
                            },
                            fontWeight: hasEvents ? 'bold' : 'normal'
                        }}
                    >
                        {day}
                        {hasEvents && (
                            <Box
                                sx={{
                                    position: 'absolute',
                                    bottom: 2,
                                    width: 4,
                                    height: 4,
                                    borderRadius: '50%',
                                    bgcolor: isSelected ? 'white' : 'primary.main'
                                }}
                            />
                        )}
                    </Box>
                </Grid>
            );
        }
        
        return (
            <Box>
                <Grid container spacing={1} sx={{ mb: 2 }}>
                    {daysOfWeek.map((day, index) => (
                        <Grid item key={day} xs={12/7}>
                            <Typography variant="caption" align="center" display="block">
                                {day}
                            </Typography>
                        </Grid>
                    ))}
                </Grid>
                <Grid container spacing={1}>
                    {days}
                </Grid>
            </Box>
        );
    };

    return (
        <Box sx={{ width: '100%' }}>
            <Box sx={{ mb: 4, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Typography 
                    variant="h4" 
                    component="h1" 
                    sx={{ fontWeight: 'bold' }}
                >
                    Event Calendar
                </Typography>
                <Button 
                    variant="outlined" 
                    startIcon={<FilterList />}
                    onClick={() => setShowFilters(!showFilters)}
                >
                    Filters
                </Button>
            </Box>
            
            {/* Error alert */}
            {error && (
                <Alert 
                    severity="error" 
                    sx={{ mb: 4 }}
                >
                    Error loading events: {error}
                </Alert>
            )}
            
            {/* Filters section */}
            {showFilters && (
                <Paper sx={{ p: 2, mb: 3, borderRadius: 2 }}>
                    <Grid container spacing={2} alignItems="center">
                        <Grid item xs={12} sm={6} md={4}>
                            <FormControl fullWidth size="small">
                                <InputLabel id="category-filter-label">Category</InputLabel>
                                <Select
                                    labelId="category-filter-label"
                                    id="category-filter"
                                    value={categoryFilter}
                                    label="Category"
                                    onChange={(e) => setCategoryFilter(e.target.value)}
                                >
                                    <MenuItem value="all">All Categories</MenuItem>
                                    {categories.map((category) => (
                                        <MenuItem key={category.category_id} value={category.category_id}>
                                            {category.category_name}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Grid>
                    </Grid>
                </Paper>
            )}
            
            {/* Main Calendar UI */}
            <Grid container spacing={3}>
                {/* Calendar widget */}
                <Grid item xs={12} md={7}>
                    <Paper sx={{ p: 2, borderRadius: 2 }}>
                        {/* Month navigation */}
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                            <IconButton onClick={goToPreviousMonth} aria-label="previous month">
                                <ChevronLeft />
                            </IconButton>
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <Typography variant="h6">
                                    {new Date(currentYear, currentMonth).toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}
                                </Typography>
                                <Tooltip title="Go to today">
                                    <IconButton onClick={goToToday} sx={{ ml: 1 }}>
                                        <Today fontSize="small" />
                                    </IconButton>
                                </Tooltip>
                            </Box>
                            <IconButton onClick={goToNextMonth} aria-label="next month">
                                <ChevronRight />
                            </IconButton>
                        </Box>
                        
                        {/* Calendar grid */}
                        {loading ? (
                            <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                                <CircularProgress />
                            </Box>
                        ) : (
                            renderCalendar()
                        )}
                    </Paper>
                </Grid>
                
                {/* Events for selected day */}
                <Grid item xs={12} md={5}>
                    <Paper sx={{ p: 2, borderRadius: 2, height: '100%' }}>
                        <Typography variant="h6" gutterBottom>
                            Events for {new Date(currentYear, currentMonth, selectedDay).toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}
                        </Typography>
                        {loading ? (
                            <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                                <CircularProgress />
                            </Box>
                        ) : dayEvents.length > 0 ? (
                            <Box sx={{ mt: 2 }}>
                                {dayEvents.map((event) => (
                                    <Card 
                                        key={event.event_id} 
                                        sx={{ 
                                            mb: 2, 
                                            cursor: 'pointer',
                                            transition: 'transform 0.2s, box-shadow 0.2s',
                                            '&:hover': {
                                                transform: 'translateY(-2px)',
                                                boxShadow: 3,
                                            },
                                            borderLeft: '4px solid',
                                            borderColor: getCategoryColor(event.category_id)
                                        }}
                                        onClick={() => handleEventClick(event)}
                                    >
                                        <CardContent sx={{ p: 2 }}>
                                            <Box sx={{ display: 'flex', alignItems: 'flex-start', justifyContent: 'space-between' }}>
                                                <Typography variant="subtitle1" component="div" sx={{ fontWeight: 'bold' }}>
                                                    {event.name}
                                                </Typography>
                                                <Chip 
                                                    label={formatTimeForDisplay(event.event_date)} 
                                                    size="small" 
                                                    color="primary" 
                                                    icon={<AccessTime fontSize="small" />}
                                                />
                                            </Box>
                                            <Box sx={{ display: 'flex', alignItems: 'center', mt: 1 }}>
                                                <LocationOn fontSize="small" color="action" sx={{ mr: 0.5 }} />
                                                <Typography variant="body2" color="text.secondary">
                                                    {event.location || 'No location specified'}
                                                </Typography>
                                            </Box>
                                        </CardContent>
                                    </Card>
                                ))}
                            </Box>
                        ) : (
                            <Box sx={{ py: 4, textAlign: 'center' }}>
                                <CalendarMonth sx={{ fontSize: 40, color: 'text.disabled', mb: 2 }} />
                                <Typography variant="body1" color="text.secondary">
                                    No events scheduled for this day
                                </Typography>
                                <Button 
                                    variant="outlined" 
                                    sx={{ mt: 2 }}
                                    startIcon={<Add />}
                                >
                                    Add an Event
                                </Button>
                            </Box>
                        )}
                    </Paper>
                </Grid>
            </Grid>
            
            {/* Event Details Modal */}
            <Dialog
                open={eventDetailsOpen}
                onClose={() => setEventDetailsOpen(false)}
                fullWidth
                maxWidth="sm"
            >
                {selectedEvent && (
                    <>
                        <DialogTitle sx={{ pb: 1 }}>
                            <Typography variant="h6">{selectedEvent.name}</Typography>
                        </DialogTitle>
                        <DialogContent dividers>
                            <Box sx={{ mb: 3 }}>
                                <Typography variant="subtitle1" component="div" fontWeight="medium" gutterBottom>
                                    When
                                </Typography>
                                <Typography variant="body1">
                                    {formatDateForDisplay(selectedEvent.event_date)}
                                </Typography>
                            </Box>
                            
                            <Box sx={{ mb: 3 }}>
                                <Typography variant="subtitle1" component="div" fontWeight="medium" gutterBottom>
                                    Where
                                </Typography>
                                <Typography variant="body1">
                                    {selectedEvent.location || 'No location specified'}
                                </Typography>
                            </Box>
                            
                            <Divider sx={{ my: 2 }} />
                            
                            <Box>
                                <Typography variant="subtitle1" component="div" fontWeight="medium" gutterBottom>
                                    Description
                                </Typography>
                                <Typography variant="body1">
                                    {selectedEvent.description || 'No description available'}
                                </Typography>
                            </Box>
                        </DialogContent>
                        <DialogActions sx={{ p: 2, justifyContent: 'space-between' }}>
                            <Button startIcon={<Share />} onClick={() => {
                                if (navigator.share) {
                                    navigator.share({
                                        title: selectedEvent.name,
                                        text: `Check out this event: ${selectedEvent.name}`,
                                        url: window.location.href
                                    });
                                }
                            }}>
                                Share
                            </Button>
                            <Box>
                                <Button onClick={() => setEventDetailsOpen(false)}>
                                    Close
                                </Button>
                                <Button 
                                    variant="contained" 
                                    color="primary"
                                    startIcon={<Event />}
                                    onClick={() => addToCalendar(selectedEvent)}
                                    sx={{ ml: 1 }}
                                >
                                    Add to Calendar
                                </Button>
                            </Box>
                        </DialogActions>
                    </>
                )}
            </Dialog>
        </Box>
    );
}

export default SimpleEventCalendar;

================
File: frontend/src/components/StarRating.jsx
================
// StarRating.jsx
import React, { useState, useEffect } from 'react';
import { Box, Tooltip, Typography } from '@mui/material';
import { Star, StarBorder, StarHalf } from '@mui/icons-material';

const StarRating = ({ 
    value = 0, 
    onChange, 
    precision = 0.5, 
    readOnly = false, 
    size = 'medium',
    showValue = false,
    hoverLabels = []
}) => {
    const [rating, setRating] = useState(value);
    const [hover, setHover] = useState(null);
    
    useEffect(() => {
        setRating(value);
    }, [value]);
    
    // Define icon sizes
    const iconSizes = {
        small: '1rem',
        medium: '1.5rem',
        large: '2rem'
    };
    
    // Get icon size based on size prop
    const getIconSize = () => {
        return iconSizes[size] || iconSizes.medium;
    };
    
    // Get label for current hover value
    const getHoverLabel = (hoverValue) => {
        if (!hoverLabels || hoverLabels.length === 0) return null;
        
        // If we have exact labels for each value based on our precision
        const totalSteps = 5 / precision;
        if (hoverLabels.length === totalSteps) {
            const index = Math.ceil(hoverValue / precision) - 1;
            return index >= 0 && index < hoverLabels.length ? hoverLabels[index] : null;
        }
        
        // If we just have 5 labels (one per star)
        if (hoverLabels.length === 5) {
            return hoverLabels[Math.ceil(hoverValue) - 1];
        }
        
        return null;
    };

    const handleMouseMove = (event, index) => {
        if (readOnly) return;
        
        const { left, width } = event.currentTarget.getBoundingClientRect();
        const percent = (event.clientX - left) / width;
        
        // If precision is 0.5, we'll either set to full or half star
        let value;
        if (precision === 0.5) {
            value = percent > 0.5 ? index + 1 : index + 0.5;
        } else if (precision === 0.1) {
            // For 0.1 precision, we'll round to nearest 0.1
            value = index + Math.round(percent * 10) / 10;
            // Ensure value is between index and index+1
            value = Math.max(index, Math.min(index + 1, value));
        } else {
            // For whole stars or other precision values
            value = percent > 0.5 ? index + 1 : index;
        }
        
        setHover(value);
    };

    const handleMouseLeave = () => {
        if (readOnly) return;
        setHover(null);
    };

    const handleClick = (event, index) => {
        if (readOnly) return;
        
        const { left, width } = event.currentTarget.getBoundingClientRect();
        const percent = (event.clientX - left) / width;
        
        // Similar logic as handleMouseMove
        let newRating;
        if (precision === 0.5) {
            newRating = percent > 0.5 ? index + 1 : index + 0.5;
        } else if (precision === 0.1) {
            newRating = index + Math.round(percent * 10) / 10;
            newRating = Math.max(index, Math.min(index + 1, newRating));
        } else {
            newRating = percent > 0.5 ? index + 1 : index;
        }
        
        setRating(newRating);
        if (onChange) {
            onChange(newRating);
        }
    };

    return (
        <Box 
            sx={{ 
                display: 'flex', 
                alignItems: 'center',
                cursor: readOnly ? 'default' : 'pointer'
            }}
        >
            {[...Array(5)].map((_, index) => {
                const value = index + 1;
                const displayValue = hover !== null ? hover : rating;
                
                // Determine what kind of star to show
                let icon;
                
                if (displayValue >= value) {
                    // Full star
                    icon = (
                        <Star 
                            sx={{ 
                                fontSize: getIconSize(),
                                color: 'gold',
                                transition: 'transform 0.1s',
                                '&:hover': {
                                    transform: !readOnly ? 'scale(1.2)' : 'none'
                                }
                            }} 
                        />
                    );
                } else if (displayValue >= value - 0.5 && displayValue < value) {
                    // Half star
                    icon = (
                        <StarHalf 
                            sx={{ 
                                fontSize: getIconSize(),
                                color: 'gold',
                                transition: 'transform 0.1s',
                                '&:hover': {
                                    transform: !readOnly ? 'scale(1.2)' : 'none'
                                }
                            }} 
                        />
                    );
                } else {
                    // Empty star
                    icon = (
                        <StarBorder 
                            sx={{ 
                                fontSize: getIconSize(),
                                color: 'gold',
                                transition: 'transform 0.1s',
                                '&:hover': {
                                    transform: !readOnly ? 'scale(1.2)' : 'none'
                                }
                            }} 
                        />
                    );
                }
                
                // Get hover label
                const hoverLabel = hover !== null ? getHoverLabel(hover) : null;
                
                return (
                    <Tooltip 
                        key={index} 
                        title={!readOnly && hoverLabel ? hoverLabel : ''}
                        placement="top"
                        arrow
                    >
                        <Box
                            onMouseMove={(e) => handleMouseMove(e, index)}
                            onMouseLeave={handleMouseLeave}
                            onClick={(e) => handleClick(e, index)}
                            sx={{ display: 'inline-flex' }}
                        >
                            {icon}
                        </Box>
                    </Tooltip>
                );
            })}
            
            {showValue && (
                <Typography 
                    variant="body2" 
                    color="text.secondary"
                    sx={{ ml: 1, fontWeight: 'medium' }}
                >
                    {(hover !== null ? hover : rating).toFixed(1)}
                </Typography>
            )}
        </Box>
    );
};

export default StarRating;

================
File: frontend/src/components/UserProfile.jsx
================
import React, { useState, useEffect } from 'react';
import {
    Box, Typography, Paper, Avatar, TextField, Button,
    Grid, Divider, Tab, Tabs, CircularProgress, Alert,
    Card, CardContent, List, ListItem, ListItemText,
    ListItemAvatar, ListItemSecondaryAction, Chip, Dialog,
    DialogTitle, DialogContent, DialogActions, IconButton,
    InputAdornment
} from '@mui/material';
import {
    Edit, Save, Cancel, Event, Star,
    CalendarToday, Email, AccountCircle,
    Visibility, VisibilityOff
} from '@mui/icons-material';

function UserProfile() {
    const [profile, setProfile] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [successMessage, setSuccessMessage] = useState(null);
    const [tabValue, setTabValue] = useState(0);
    const [editMode, setEditMode] = useState(false);
    const [formData, setFormData] = useState({
        email: '',
        bio: '',
        profile_picture: ''
    });
    const [activities, setActivities] = useState([]);
    const [loadingActivities, setLoadingActivities] = useState(false);
    const [changePasswordOpen, setChangePasswordOpen] = useState(false);
    const [passwordData, setPasswordData] = useState({
        currentPassword: '',
        newPassword: '',
        confirmPassword: ''
    });
    const [passwordError, setPasswordError] = useState(null);
    const [passwordSuccess, setPasswordSuccess] = useState(null);
    const [showCurrentPassword, setShowCurrentPassword] = useState(false);
    const [showNewPassword, setShowNewPassword] = useState(false);

    // Get token from localStorage
    const getToken = () => {
        // Add debugging output
        const token = localStorage.getItem('authToken');
        console.log('Token found in UserProfile:', token ? 'Yes' : 'No');
        return token;
    };

    // Fetch user profile
    useEffect(() => {
        const fetchUserProfile = async () => {
            setLoading(true);
            try {
                const token = getToken();
                if (!token) {
                    throw new Error('No authentication token found');
                }

                const headers = {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                };

                console.log('UserProfile: Fetching profile with token');

                const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
                // Make request to backend - ensure it includes the full URL
                const response = await fetch(`${apiUrl}/api/users/profile`, { headers });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Profile fetch error:', response.status, errorData);
                    throw new Error(errorData.error || `Failed to fetch profile: ${response.status}`);
                }

                const data = await response.json();
                console.log('Profile data received');

                setProfile(data);
                setFormData({
                    email: data.email || '',
                    bio: data.bio || '',
                    profile_picture: data.profile_picture || ''
                });
                setError(null);
            } catch (err) {
                console.error('Error fetching profile:', err);
                setError(`Failed to load profile data: ${err.message}`);
            } finally {
                setLoading(false);
            }
        };

        fetchUserProfile();
    }, []);

    // Fetch user activities
    const fetchUserActivities = async () => {
        if (tabValue !== 1) return;

        setLoadingActivities(true);
        try {
            const token = getToken();
            if (!token) {
                throw new Error('No authentication token found');
            }

            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };

            // Use full URL for API call
            const response = await fetch('http://localhost:5000/api/users/activities', { headers });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Failed to fetch activities: ${response.status}`);
            }

            const data = await response.json();
            setActivities(data);
        } catch (err) {
            console.error('Error fetching activities:', err);
        } finally {
            setLoadingActivities(false);
        }
    };

    useEffect(() => {
        fetchUserActivities();
    }, [tabValue]);

    const handleTabChange = (event, newValue) => {
        setTabValue(newValue);
    };

    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setFormData({
            ...formData,
            [name]: value
        });
    };

    const handleEditToggle = () => {
        if (editMode) {
            // Cancel editing - reset form data to original profile values
            setFormData({
                email: profile.email || '',
                bio: profile.bio || '',
                profile_picture: profile.profile_picture || ''
            });
        }
        setEditMode(!editMode);
        setSuccessMessage(null);
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setLoading(true);
        setSuccessMessage(null);
        setError(null);

        try {
            const token = getToken();
            if (!token) {
                throw new Error('No authentication token found');
            }

            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };

            // Use full URL for API call
            const response = await fetch('http://localhost:5000/api/users/profile', {
                method: 'PUT',
                headers,
                body: JSON.stringify(formData)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Failed to update profile: ${response.status}`);
            }

            const updatedProfile = await response.json();
            setProfile(updatedProfile);
            setEditMode(false);
            setSuccessMessage('Profile updated successfully!');
        } catch (err) {
            console.error('Error updating profile:', err);
            setError(err.message || 'Failed to update profile. Please try again.');
        } finally {
            setLoading(false);
        }
    };

    const handlePasswordChange = async (e) => {
        e.preventDefault();
        setPasswordError(null);
        setPasswordSuccess(null);

        if (passwordData.newPassword !== passwordData.confirmPassword) {
            setPasswordError('New passwords do not match');
            return;
        }

        try {
            const token = getToken();
            if (!token) {
                throw new Error('No authentication token found');
            }

            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };

            // Use full URL for API call
            const response = await fetch('http://localhost:5000/api/users/password', {
                method: 'PUT',
                headers,
                body: JSON.stringify({
                    currentPassword: passwordData.currentPassword,
                    newPassword: passwordData.newPassword
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Failed to update password: ${response.status}`);
            }

            setPasswordSuccess('Password updated successfully!');
            setPasswordData({
                currentPassword: '',
                newPassword: '',
                confirmPassword: ''
            });

            // Close dialog after 2 seconds
            setTimeout(() => {
                setChangePasswordOpen(false);
                setPasswordSuccess(null);
            }, 2000);
        } catch (err) {
            console.error('Error updating password:', err);
            setPasswordError(err.message || 'Failed to update password');
        }
    };

    const handlePasswordInputChange = (e) => {
        const { name, value } = e.target;
        setPasswordData({
            ...passwordData,
            [name]: value
        });
        setPasswordError(null);
    };

    const formatDate = (dateString) => {
        const date = new Date(dateString);
        return new Intl.DateTimeFormat('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric'
        }).format(date);
    };

    // Loading state
    if (loading && !profile) {
        return (
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '300px' }}>
                <CircularProgress />
            </Box>
        );
    }

    // Error state
    if (error && !profile) {
        return (
            <Box sx={{ maxWidth: 'sm', mx: 'auto', mt: 4 }}>
                <Alert severity="error">{error}</Alert>
                <Button
                    variant="contained"
                    sx={{ mt: 2 }}
                    onClick={() => window.location.reload()}
                >
                    Retry
                </Button>
            </Box>
        );
    }

    return (
        <Box sx={{ width: '100%' }}>
            {/* Header Section */}
            <Paper sx={{ p: 4, mb: 3, borderRadius: 2 }}>
                <Grid container spacing={3} alignItems="center">
                    <Grid item xs={12} sm={2}>
                        <Avatar
                            src={profile?.profile_picture || ''}
                            alt={profile?.username}
                            sx={{ width: 100, height: 100, mx: { xs: 'auto', sm: 0 } }}
                        >
                            {profile?.username?.charAt(0).toUpperCase()}
                        </Avatar>
                    </Grid>
                    <Grid item xs={12} sm={8}>
                        <Typography variant="h4" component="h1" gutterBottom>
                            {profile?.username}
                        </Typography>
                        <Typography variant="body1" color="text.secondary">
                            Member since {formatDate(profile?.created_at || profile?.registration_date)}
                        </Typography>
                    </Grid>
                    <Grid item xs={12} sm={2}>
                        <Button
                            variant="contained"
                            color={editMode ? "error" : "primary"}
                            startIcon={editMode ? <Cancel /> : <Edit />}
                            onClick={handleEditToggle}
                            fullWidth
                        >
                            {editMode ? 'Cancel' : 'Edit Profile'}
                        </Button>
                    </Grid>
                </Grid>

                {successMessage && (
                    <Alert severity="success" sx={{ mt: 2 }}>
                        {successMessage}
                    </Alert>
                )}

                {error && editMode && (
                    <Alert severity="error" sx={{ mt: 2 }}>
                        {error}
                    </Alert>
                )}
            </Paper>

            {/* Tabs and Content */}
            <Paper sx={{ borderRadius: 2 }}>
                <Tabs
                    value={tabValue}
                    onChange={handleTabChange}
                    sx={{ borderBottom: 1, borderColor: 'divider' }}
                >
                    <Tab label="Profile Information" />
                    <Tab label="Activity" />
                    <Tab label="Security" />
                </Tabs>

                {/* Profile Information Tab */}
                {tabValue === 0 && (
                    <Box sx={{ p: 3 }}>
                        {editMode ? (
                            <form onSubmit={handleSubmit}>
                                <Grid container spacing={3}>
                                    <Grid item xs={12}>
                                        <TextField
                                            label="Email"
                                            name="email"
                                            value={formData.email}
                                            onChange={handleInputChange}
                                            fullWidth
                                            margin="normal"
                                            InputProps={{
                                                startAdornment: (
                                                    <InputAdornment position="start">
                                                        <Email />
                                                    </InputAdornment>
                                                ),
                                            }}
                                        />
                                    </Grid>
                                    <Grid item xs={12}>
                                        <TextField
                                            label="Profile Picture URL"
                                            name="profile_picture"
                                            value={formData.profile_picture}
                                            onChange={handleInputChange}
                                            fullWidth
                                            margin="normal"
                                            placeholder="Enter a URL for your profile picture"
                                            helperText="Leave empty to use initials"
                                        />
                                    </Grid>
                                    <Grid item xs={12}>
                                        <TextField
                                            label="Bio"
                                            name="bio"
                                            value={formData.bio}
                                            onChange={handleInputChange}
                                            fullWidth
                                            margin="normal"
                                            multiline
                                            rows={4}
                                            placeholder="Tell us about yourself..."
                                        />
                                    </Grid>
                                    <Grid item xs={12}>
                                        <Button
                                            type="submit"
                                            variant="contained"
                                            color="primary"
                                            startIcon={<Save />}
                                            disabled={loading}
                                            sx={{ mt: 2 }}
                                        >
                                            {loading ? 'Saving...' : 'Save Changes'}
                                        </Button>
                                    </Grid>
                                </Grid>
                            </form>
                        ) : (
                            <Grid container spacing={3}>
                                <Grid item xs={12}>
                                    <Box sx={{ mb: 3 }}>
                                        <Typography variant="overline" color="text.secondary">
                                            Email
                                        </Typography>
                                        <Typography variant="body1" sx={{ display: 'flex', alignItems: 'center', mt: 1 }}>
                                            <Email fontSize="small" sx={{ mr: 1, color: 'primary.main' }} />
                                            {profile?.email || 'No email provided'}
                                        </Typography>
                                    </Box>
                                </Grid>
                                <Grid item xs={12}>
                                    <Divider sx={{ my: 2 }} />
                                    <Typography variant="overline" color="text.secondary">
                                        Bio
                                    </Typography>
                                    <Typography variant="body1" sx={{ mt: 1 }}>
                                        {profile?.bio || 'No bio provided. Tell us about yourself!'}
                                    </Typography>
                                </Grid>
                            </Grid>
                        )}
                    </Box>
                )}

                {/* Activity Tab */}
                {tabValue === 1 && (
                    <Box sx={{ p: 3 }}>
                        <Typography variant="h6" gutterBottom>
                            Recent Activity
                        </Typography>

                        {loadingActivities ? (
                            <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                                <CircularProgress />
                            </Box>
                        ) : activities.length === 0 ? (
                            <Box sx={{ textAlign: 'center', py: 4 }}>
                                <Typography variant="body1" color="text.secondary">
                                    No recent activity found
                                </Typography>
                            </Box>
                        ) : (
                            <List>
                                {activities.map((activity, index) => (
                                    <React.Fragment key={`${activity.activity_type}-${activity.event_id || activity.review_id}`}>
                                        <ListItem alignItems="flex-start">
                                            <ListItemAvatar>
                                                <Avatar sx={{ bgcolor: activity.activity_type === 'event_created' ? 'primary.main' : 'secondary.main' }}>
                                                    {activity.activity_type === 'event_created' ? <Event /> : <Star />}
                                                </Avatar>
                                            </ListItemAvatar>
                                            <ListItemText
                                                primary={
                                                    <Typography variant="subtitle1">
                                                        {activity.activity_type === 'event_created'
                                                            ? 'Created event: '
                                                            : 'Reviewed event: '}
                                                        <Typography component="span" fontWeight="bold">
                                                            {activity.name}
                                                        </Typography>
                                                    </Typography>
                                                }
                                                secondary={
                                                    <>
                                                        <Typography variant="body2" color="text.secondary">
                                                            {formatDate(activity.created_at)}
                                                        </Typography>
                                                        {activity.activity_type === 'review_submitted' && (
                                                            <Box sx={{ mt: 1, display: 'flex', alignItems: 'center' }}>
                                                                {[...Array(5)].map((_, i) => (
                                                                    <Star
                                                                        key={i}
                                                                        fontSize="small"
                                                                        sx={{
                                                                            color: i < activity.rating ? 'gold' : 'gray',
                                                                            mr: 0.5
                                                                        }}
                                                                    />
                                                                ))}
                                                            </Box>
                                                        )}
                                                        {activity.activity_type === 'event_created' && activity.event_date && (
                                                            <Box sx={{ mt: 1, display: 'flex', alignItems: 'center' }}>
                                                                <CalendarToday fontSize="small" sx={{ mr: 0.5 }} />
                                                                <Typography variant="body2">
                                                                    {formatDate(activity.event_date)}
                                                                </Typography>
                                                            </Box>
                                                        )}
                                                    </>
                                                }
                                            />
                                            <ListItemSecondaryAction>
                                                <Chip
                                                    label={activity.activity_type === 'event_created' ? 'Created' : 'Reviewed'}
                                                    color={activity.activity_type === 'event_created' ? 'primary' : 'secondary'}
                                                    size="small"
                                                />
                                            </ListItemSecondaryAction>
                                        </ListItem>
                                        {index < activities.length - 1 && <Divider component="li" />}
                                    </React.Fragment>
                                ))}
                            </List>
                        )}
                    </Box>
                )}

                {/* Security Tab */}
                {tabValue === 2 && (
                    <Box sx={{ p: 3 }}>
                        <Typography variant="h6" gutterBottom>
                            Account Security
                        </Typography>

                        <Card sx={{ mb: 3 }}>
                            <CardContent>
                                <Typography variant="h6" component="div">
                                    Password
                                </Typography>
                                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                                    Change your account password regularly to keep your account secure.
                                </Typography>
                                <Button
                                    variant="outlined"
                                    onClick={() => setChangePasswordOpen(true)}
                                >
                                    Change Password
                                </Button>
                            </CardContent>
                        </Card>

                        <Card>
                            <CardContent>
                                <Typography variant="h6" component="div">
                                    Account
                                </Typography>
                                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                                    Download your data or delete your account.
                                </Typography>
                                <Box sx={{ display: 'flex', gap: 2 }}>
                                    <Button variant="outlined">
                                        Download My Data
                                    </Button>
                                    <Button variant="outlined" color="error">
                                        Delete Account
                                    </Button>
                                </Box>
                            </CardContent>
                        </Card>
                    </Box>
                )}
            </Paper>

            {/* Change Password Dialog */}
            <Dialog
                open={changePasswordOpen}
                onClose={() => {
                    if (!passwordSuccess) {
                        setChangePasswordOpen(false);
                        setPasswordData({
                            currentPassword: '',
                            newPassword: '',
                            confirmPassword: ''
                        });
                        setPasswordError(null);
                    }
                }}
                fullWidth
                maxWidth="sm"
            >
                <DialogTitle>Change Password</DialogTitle>
                <DialogContent>
                    {passwordError && (
                        <Alert severity="error" sx={{ mb: 2 }}>
                            {passwordError}
                        </Alert>
                    )}

                    {passwordSuccess && (
                        <Alert severity="success" sx={{ mb: 2 }}>
                            {passwordSuccess}
                        </Alert>
                    )}

                    <form id="change-password-form" onSubmit={handlePasswordChange}>
                        <TextField
                            label="Current Password"
                            name="currentPassword"
                            type={showCurrentPassword ? 'text' : 'password'}
                            value={passwordData.currentPassword}
                            onChange={handlePasswordInputChange}
                            fullWidth
                            margin="normal"
                            required
                            InputProps={{
                                endAdornment: (
                                    <InputAdornment position="end">
                                        <IconButton
                                            onClick={() => setShowCurrentPassword(!showCurrentPassword)}
                                            edge="end"
                                        >
                                            {showCurrentPassword ? <VisibilityOff /> : <Visibility />}
                                        </IconButton>
                                    </InputAdornment>
                                ),
                            }}
                        />

                        <TextField
                            label="New Password"
                            name="newPassword"
                            type={showNewPassword ? 'text' : 'password'}
                            value={passwordData.newPassword}
                            onChange={handlePasswordInputChange}
                            fullWidth
                            margin="normal"
                            required
                            InputProps={{
                                endAdornment: (
                                    <InputAdornment position="end">
                                        <IconButton
                                            onClick={() => setShowNewPassword(!showNewPassword)}
                                            edge="end"
                                        >
                                            {showNewPassword ? <VisibilityOff /> : <Visibility />}
                                        </IconButton>
                                    </InputAdornment>
                                ),
                            }}
                        />

                        <TextField
                            label="Confirm New Password"
                            name="confirmPassword"
                            type="password"
                            value={passwordData.confirmPassword}
                            onChange={handlePasswordInputChange}
                            fullWidth
                            margin="normal"
                            required
                            error={passwordData.newPassword !== passwordData.confirmPassword}
                            helperText={
                                passwordData.newPassword !== passwordData.confirmPassword ?
                                    "Passwords don't match" : ""
                            }
                        />
                    </form>
                </DialogContent>
                <DialogActions>
                    <Button
                        onClick={() => {
                            setChangePasswordOpen(false);
                            setPasswordData({
                                currentPassword: '',
                                newPassword: '',
                                confirmPassword: ''
                            });
                            setPasswordError(null);
                        }}
                    >
                        Cancel
                    </Button>
                    <Button
                        type="submit"
                        form="change-password-form"
                        variant="contained"
                        color="primary"
                        disabled={!!passwordSuccess}
                    >
                        Update Password
                    </Button>
                </DialogActions>
            </Dialog>
        </Box>
    );
}

export default UserProfile;

================
File: frontend/src/index.css
================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  padding: 0;
  min-width: 100vw;
  min-height: 100vh;
  /* Removed display: flex and place-items: center */
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

================
File: frontend/src/main.jsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: frontend/src/utils/api.js
================
export const fetchApi = async (endpoint, options = {}) => {
    const baseUrl = import.meta.env.VITE_API_URL || 
                    'https://evently-production-cd21.up.railway.app';
    
    console.group('ðŸŒ API Request');
    console.log('Endpoint:', endpoint);
    console.log('Base URL:', baseUrl);

    try {
        const response = await fetch(`${baseUrl}${endpoint}`, {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                'Origin': window.location.origin,
                ...options.headers
            },
            credentials: 'include'  // Critical for cross-origin credentials
        });

        console.log('Response Status:', response.status);

        if (!response.ok) {
            const errorBody = await response.text();
            console.error('âŒ API Error:', errorBody);
            throw new Error(errorBody || 'Network response was not ok');
        }

        const data = await response.json();
        console.log('Response Data:', data);
        console.groupEnd();

        return data;
    } catch (error) {
        console.error('ðŸš¨ Fetch Error:', error);
        console.groupEnd();
        throw error;
    }
};

================
File: frontend/src/utils/CalendarExport.js
================
// Create a new file in src/utils/CalendarExport.js

/**
 * Utility functions for calendar exports
 */

// Format date for iCalendar (YYYYMMDDTHHMMSSZ)
const formatICalDate = (date) => {
    const pad = (num) => (num < 10 ? '0' : '') + num;
    
    const year = date.getFullYear();
    const month = pad(date.getMonth() + 1);
    const day = pad(date.getDate());
    const hours = pad(date.getHours());
    const minutes = pad(date.getMinutes());
    const seconds = pad(date.getSeconds());
    
    return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
};

// Generate a random string for unique identifiers
const generateUID = () => {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
};

/**
 * Generate an iCalendar file for a single event
 * @param {Object} event - The event object
 * @returns {string} - iCalendar formatted string
 */
export const generateICalEvent = (event) => {
    const { name, description, location, event_date } = event;
    const eventStart = new Date(event_date);
    // Default duration 1 hour
    const eventEnd = new Date(eventStart.getTime() + 60 * 60 * 1000);
    
    const now = new Date();
    const uid = generateUID();
    
    let iCalContent = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//Evently//NONSGML Event Calendar//EN',
        'CALSCALE:GREGORIAN',
        'METHOD:PUBLISH',
        'BEGIN:VEVENT',
        `UID:${uid}`,
        `DTSTAMP:${formatICalDate(now)}`,
        `DTSTART:${formatICalDate(eventStart)}`,
        `DTEND:${formatICalDate(eventEnd)}`,
        `SUMMARY:${name}`,
    ].join('\r\n');
    
    // Add optional fields if available
    if (description) {
        iCalContent += `\r\nDESCRIPTION:${description.replace(/\n/g, '\\n')}`;
    }
    
    if (location) {
        iCalContent += `\r\nLOCATION:${location}`;
    }
    
    // Add end of event and calendar
    iCalContent += '\r\nEND:VEVENT\r\nEND:VCALENDAR';
    
    return iCalContent;
};

/**
 * Download an iCalendar file for an event
 * @param {Object} event - The event object
 */
export const downloadICalEvent = (event) => {
    const iCalContent = generateICalEvent(event);
    const blob = new Blob([iCalContent], { type: 'text/calendar;charset=utf-8' });
    
    // Create a download link and trigger it
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${event.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.ics`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

/**
 * Create Google Calendar URL for an event
 * @param {Object} event - The event object
 * @returns {string} - Google Calendar URL
 */
export const getGoogleCalendarUrl = (event) => {
    const { name, description, location, event_date } = event;
    const eventStart = new Date(event_date);
    // Default duration 1 hour
    const eventEnd = new Date(eventStart.getTime() + 60 * 60 * 1000);
    
    // Format dates for Google Calendar
    const formatGoogleDate = (date) => {
        return date.toISOString().replace(/-|:|\.\d\d\d/g, '');
    };
    
    const params = new URLSearchParams({
        action: 'TEMPLATE',
        text: name,
        dates: `${formatGoogleDate(eventStart)}/${formatGoogleDate(eventEnd)}`,
        details: description || '',
        location: location || '',
        sf: 'true',
        output: 'xml'
    });
    
    return `https://calendar.google.com/calendar/render?${params.toString()}`;
};

/**
 * Create Outlook Calendar URL for an event
 * @param {Object} event - The event object
 * @returns {string} - Outlook Calendar URL
 */
export const getOutlookCalendarUrl = (event) => {
    const { name, description, location, event_date } = event;
    const eventStart = new Date(event_date);
    // Default duration 1 hour
    const eventEnd = new Date(eventStart.getTime() + 60 * 60 * 1000);
    
    const params = new URLSearchParams({
        path: '/calendar/action/compose',
        rru: 'addevent',
        subject: name,
        startdt: eventStart.toISOString(),
        enddt: eventEnd.toISOString(),
        body: description || '',
        location: location || ''
    });
    
    return `https://outlook.office.com/calendar/0/deeplink/compose?${params.toString()}`;
};

export default {
    downloadICalEvent,
    getGoogleCalendarUrl,
    getOutlookCalendarUrl
};

================
File: frontend/src/utils/getApiUrl.js
================
export function getApiUrl() {
  // Use environment variable for flexibility
  return import.meta.env.VITE_API_URL ||
    'https://evently-production-cd21.up.railway.app';
}

================
File: frontend/vite.config.js
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

================
File: railway.json
================
{
    "build": {
        "builder": "nixpacks",
        "buildCommand": "curl -fsSL https://deb.nodesource.com/setup_18.x | bash - && apt-get install -y nodejs && cd backend && npm install"
    },
    "deploy": {
        "startCommand": "cd backend && npm start",
        "healthcheckPath": "/",
        "healthcheckTimeout": 100,
        "envs": {
            "PORT": "5000",
            "NODE_ENV": "production",
            "DB_HOST": "${{ RAILWAY_TCP_PROXY_HOST }}",
            "DB_PORT": "${{ RAILWAY_TCP_PROXY_PORT }}",
            "DB_USER": "${{ MYSQL_USER }}",
            "DB_PASSWORD": "${{ MYSQL_PASSWORD }}",
            "DB_DATABASE": "${{ MYSQL_DATABASE }}",
            "JWT_SECRET": "${{ JWT_SECRET }}"
        }
    }
}

================
File: vercel.json
================
{
    "buildCommand": "npm install --legacy-peer-deps && npm run build",
    "outputDirectory": "dist",
    "framework": "vite",
    "routes": [
        { "handle": "filesystem" },
        { 
            "src": "/(.*)", 
            "dest": "/index.html",
            "headers": {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS",
                "Access-Control-Allow-Headers": "Content-Type, Authorization"
            }
        }
    ],
    "env": {
        "VITE_API_URL": "https://evently-production-cd21.up.railway.app"
    }
}



================================================================
End of Codebase
================================================================
